import { asyncToGenerator as _asyncToGenerator, createForOfIteratorHelper as _createForOfIteratorHelper, slicedToArray as _slicedToArray } from './_virtual/_rollupPluginBabelHelpers.js';
import { retain, release } from '@remote-ui/rpc';

function makeStatefulSubscribable(subscription) {
  // We retain because it will automatically retain any functions we get from
  // calling functions on this object, which will automatically manage the memory
  // for unsubscribe callbacks received from subscription.subscribe().
  retain(subscription);
  var current = subscription.initial;
  var listening = true;
  var subscribers = new Set();
  var subscriptionResult = Promise.resolve(subscription.subscribe(listener)).then(function (result) {
    listener(result[1]);
    return result;
  });
  return {
    get current() {
      return current;
    },

    subscribe: function subscribe(subscriber) {
      subscribers.add(subscriber);
      return function () {
        subscribers.delete(subscriber);
      };
    },
    destroy: function destroy() {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _yield$subscriptionRe, _yield$subscriptionRe2, unsubscribe;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                listening = false;
                subscribers.clear();
                _context.next = 4;
                return subscriptionResult;

              case 4:
                _yield$subscriptionRe = _context.sent;
                _yield$subscriptionRe2 = _slicedToArray(_yield$subscriptionRe, 1);
                unsubscribe = _yield$subscriptionRe2[0];
                unsubscribe();
                release(subscription);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  };

  function listener(value) {
    if (!listening || current === value) return;
    current = value;

    var _iterator = _createForOfIteratorHelper(subscribers),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var subscriber = _step.value;
        subscriber(current);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
}

export { makeStatefulSubscribable };
