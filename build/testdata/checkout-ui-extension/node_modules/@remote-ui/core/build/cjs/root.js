'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var types = require('./types.js');
var utilities = require('./utilities.js');

var FUNCTION_CURRENT_IMPLEMENTATION_KEY = '__current';
var EMPTY_OBJECT = {};
var EMPTY_ARRAY = [];
function createRemoteRoot(channel) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$strict = _ref.strict,
      strict = _ref$strict === void 0 ? true : _ref$strict,
      components = _ref.components;

  var currentId = 0;
  var rootInternals = {
    strict: strict,
    mounted: false,
    channel: channel,
    children: EMPTY_ARRAY,
    nodes: new WeakSet(),
    parents: new WeakMap(),
    tops: new WeakMap()
  };
  if (strict) Object.freeze(components);
  var remoteRoot = {
    kind: types.KIND_ROOT,
    options: strict ? Object.freeze({
      strict: strict,
      components: components
    }) : {
      strict: strict,
      components: components
    },

    get children() {
      return rootInternals.children;
    },

    createComponent: function createComponent(type) {
      if (components && components.indexOf(type) < 0) {
        throw new Error("Unsupported component: ".concat(type));
      }

      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      var initialProps = rest[0],
          initialChildren = rest[1],
          moreChildren = rest.slice(2);
      var normalizedInitialProps = initialProps !== null && initialProps !== void 0 ? initialProps : {};
      var normalizedInitialChildren = [];
      var normalizedInternalProps = {};

      if (initialProps) {
        for (var _i = 0, _Object$keys = Object.keys(initialProps); _i < _Object$keys.length; _i++) {
          var _key2 = _Object$keys[_i];
          // "children" as a prop can be extremely confusing with the "children" of
          // a component. In React, a "child" can be anything, but once it reaches
          // a host environment (like this remote `Root`), we want "children" to have
          // only one meaning: the actual, resolved children components and text.
          //
          // To enforce this, we delete any prop named "children". We don’t take a copy
          // of the props for performance, so a user calling this function must do so
          // with an object that can handle being mutated.
          if (_key2 === 'children') continue;
          normalizedInternalProps[_key2] = makeValueHotSwappable(serializeProp(initialProps[_key2]));
        }
      }

      if (initialChildren) {
        if (Array.isArray(initialChildren)) {
          var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(initialChildren),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              normalizedInitialChildren.push(normalizeChild(child, remoteRoot));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          normalizedInitialChildren.push(normalizeChild(initialChildren, remoteRoot)); // The complex tuple type of `rest` makes it so `moreChildren` is
          // incorrectly inferred as potentially being the props of the component,
          // lazy casting since we know it will be an array of child elements
          // (or empty).

          var _iterator2 = _rollupPluginBabelHelpers.createForOfIteratorHelper(moreChildren),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _child = _step2.value;
              normalizedInitialChildren.push(normalizeChild(_child, remoteRoot));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }

      var id = "".concat(currentId++);
      var internals = {
        externalProps: strict ? Object.freeze(normalizedInitialProps) : normalizedInitialProps,
        internalProps: normalizedInternalProps,
        children: strict ? Object.freeze(normalizedInitialChildren) : normalizedInitialChildren
      };

      var component = _rollupPluginBabelHelpers.objectSpread2({
        kind: types.KIND_COMPONENT,

        get children() {
          return internals.children;
        },

        get props() {
          return internals.externalProps;
        },

        get remoteProps() {
          return internals.internalProps;
        },

        updateProps: function updateProps(newProps) {
          return _updateProps(component, newProps, internals, rootInternals);
        },
        appendChild: function appendChild(child) {
          return _appendChild(component, normalizeChild(child, remoteRoot), internals, rootInternals);
        },
        removeChild: function removeChild(child) {
          return _removeChild(component, child, internals, rootInternals);
        },
        insertChildBefore: function insertChildBefore(child, before) {
          return _insertChildBefore(component, normalizeChild(child, remoteRoot), before, internals, rootInternals);
        }
      }, EMPTY_OBJECT);

      Object.defineProperty(component, 'type', {
        value: type,
        configurable: false,
        writable: false,
        enumerable: true
      });
      makePartOfTree(component, rootInternals);
      makeRemote(component, id, remoteRoot);

      var _iterator3 = _rollupPluginBabelHelpers.createForOfIteratorHelper(internals.children),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _child2 = _step3.value;
          moveNodeToContainer(component, _child2, rootInternals);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return component;
    },
    createText: function createText() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var id = "".concat(currentId++);
      var internals = {
        text: content
      };

      var text = _rollupPluginBabelHelpers.objectSpread2({
        kind: types.KIND_TEXT,

        get text() {
          return internals.text;
        },

        updateText: function updateText(newText) {
          return _updateText(text, newText, internals, rootInternals);
        }
      }, EMPTY_OBJECT);

      makePartOfTree(text, rootInternals);
      makeRemote(text, id, remoteRoot);
      return text;
    },
    createFragment: function createFragment() {
      var id = "".concat(currentId++);
      var internals = {
        children: strict ? Object.freeze([]) : []
      };

      var fragment = _rollupPluginBabelHelpers.objectSpread2({
        kind: types.KIND_FRAGMENT,

        get children() {
          return internals.children;
        },

        appendChild: function appendChild(child) {
          return _appendChild(fragment, normalizeChild(child, remoteRoot), internals, rootInternals);
        },
        removeChild: function removeChild(child) {
          return _removeChild(fragment, child, internals, rootInternals);
        },
        insertChildBefore: function insertChildBefore(child, before) {
          return _insertChildBefore(fragment, normalizeChild(child, remoteRoot), before, internals, rootInternals);
        }
      }, EMPTY_OBJECT);

      makePartOfTree(fragment, rootInternals);
      makeRemote(fragment, id, remoteRoot);
      return fragment;
    },
    appendChild: function appendChild(child) {
      return _appendChild(remoteRoot, normalizeChild(child, remoteRoot), rootInternals, rootInternals);
    },
    removeChild: function removeChild(child) {
      return _removeChild(remoteRoot, child, rootInternals, rootInternals);
    },
    insertChildBefore: function insertChildBefore(child, before) {
      return _insertChildBefore(remoteRoot, normalizeChild(child, remoteRoot), before, rootInternals, rootInternals);
    },
    mount: function mount() {
      if (rootInternals.mounted) return Promise.resolve();
      rootInternals.mounted = true;
      return Promise.resolve(channel(types.ACTION_MOUNT, rootInternals.children.map(serializeChild)));
    }
  };
  return remoteRoot;
}

function connected(element, _ref2) {
  var _tops$get;

  var tops = _ref2.tops;
  return ((_tops$get = tops.get(element)) === null || _tops$get === void 0 ? void 0 : _tops$get.kind) === types.KIND_ROOT;
}

function allDescendants(element, withEach) {
  var recurse = function recurse(element) {
    if ('children' in element) {
      var _iterator4 = _rollupPluginBabelHelpers.createForOfIteratorHelper(element.children),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var child = _step4.value;
          withEach(child);
          recurse(child);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  };

  recurse(element);
}

function perform(element, rootInternals, _ref3) {
  var remote = _ref3.remote,
      local = _ref3.local;
  var mounted = rootInternals.mounted,
      channel = rootInternals.channel;

  if (mounted && (element.kind === types.KIND_ROOT || connected(element, rootInternals))) {
    // should only create context once async queue is cleared
    remote(channel); // technically, we should be waiting for the remote update to apply,
    // then apply it locally. The implementation below is too naive because
    // it allows local updates to get out of sync with remote ones.
    // if (remoteResult == null || !('then' in remoteResult)) {
    //   local();
    //   return;
    // } else {
    //   return remoteResult.then(() => {
    //     local();
    //   });
    // }
  }

  local();
}

function _updateText(text, newText, internals, rootInternals) {
  return perform(text, rootInternals, {
    remote: function remote(channel) {
      return channel(types.ACTION_UPDATE_TEXT, text.id, newText);
    },
    local: function local() {
      internals.text = newText;
    }
  });
}

var IGNORE = Symbol('ignore');

function _updateProps(component, newProps, internals, rootInternals) {
  var strict = rootInternals.strict;
  var currentProps = internals.internalProps,
      currentExternalProps = internals.externalProps;
  var normalizedNewProps = {};
  var hotSwapFunctions = [];
  var hasRemoteChange = false;

  for (var _i2 = 0, _Object$keys2 = Object.keys(newProps); _i2 < _Object$keys2.length; _i2++) {
    var _key3 = _Object$keys2[_i2];
    // See notes above for why we treat `children` as a reserved prop.
    if (_key3 === 'children') continue;
    var currentExternalValue = currentExternalProps[_key3];
    var newExternalValue = newProps[_key3];
    var currentValue = currentProps[_key3];
    var newValue = serializeProp(newExternalValue); // Bail out if we have equal, primitive types

    if (currentValue === newValue && (newValue == null || _rollupPluginBabelHelpers['typeof'](newValue) !== 'object')) {
      continue;
    }

    var _tryHotSwappingValues = tryHotSwappingValues(currentValue, newValue),
        _tryHotSwappingValues2 = _rollupPluginBabelHelpers.slicedToArray(_tryHotSwappingValues, 2),
        value = _tryHotSwappingValues2[0],
        hotSwaps = _tryHotSwappingValues2[1];

    if (hotSwaps) {
      hotSwapFunctions.push.apply(hotSwapFunctions, _rollupPluginBabelHelpers.toConsumableArray(hotSwaps));
    }

    if (value === IGNORE) continue;
    hasRemoteChange = true;
    normalizedNewProps[_key3] = value;

    if (utilities.isRemoteFragment(currentExternalValue)) {
      removeNodeFromContainer(currentExternalValue, rootInternals);
    }

    if (utilities.isRemoteFragment(newExternalValue)) {
      moveNodeToContainer(component, newExternalValue, rootInternals);
    }
  }

  return perform(component, rootInternals, {
    remote: function remote(channel) {
      if (hasRemoteChange) {
        channel(types.ACTION_UPDATE_PROPS, component.id, normalizedNewProps);
      }
    },
    local: function local() {
      var mergedExternalProps = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, currentExternalProps), newProps);

      internals.externalProps = strict ? Object.freeze(mergedExternalProps) : mergedExternalProps;
      internals.internalProps = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, internals.internalProps), normalizedNewProps);

      var _iterator5 = _rollupPluginBabelHelpers.createForOfIteratorHelper(hotSwapFunctions),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _rollupPluginBabelHelpers.slicedToArray(_step5.value, 2),
              hotSwappable = _step5$value[0],
              _newValue = _step5$value[1];

          hotSwappable[FUNCTION_CURRENT_IMPLEMENTATION_KEY] = _newValue;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  });
} // Imagine the following remote-ui components we might render in a remote context:
//
// const root = createRemoteRoot();
// const {value, onChange, onPress} = getPropsForValue();
//
// const textField = root.createComponent('TextField', {value, onChange});
// const button = root.createComponent('Button', {onPress});
//
// root.appendChild(textField);
// root.appendChild(button);
//
// function getPropsForValue(value = '') {
//   return {
//     value,
//     onChange: () => {
//       const {value, onChange, onPress} = getPropsForValue();
//       textField.updateProps({value, onChange});
//       button.updateProps({onPress});
//     },
//     onPress: () => console.log(value),
//   };
// }
//
//
// In this example, assume that the `TextField` `onChange` prop is run on blur.
// If this were running on the host, the following steps would happen if you pressed
// on the button:
//
// 1. The text field blurs, and so calls `onChange()` with its current value, which
//    then calls `setValue()` with the updated value.
// 2. We synchronously update the `value`, `onChange`, and `onPress` props to point at
//    the most current `value`.
// 3. Handling blur is finished, so the browser now handles the click by calling the
//    (newly-updated) `Button` `onPress()`, which logs out the new value.
//
// Because remote-ui reproduces a UI tree asynchronously from the remote context, the
// steps above run in a different order:
//
// 1. The text field blurs, and so calls `onChange()` with its current value.
// 2. Handling blur is finished **from the perspective of the main thread**, so the
//    browser now handles the click by calling the (original) `Button` `onPress()`, which
//    logs out the **initial** value.
// 3. In the remote context, we receive the `onChange()` call, which calls updates the props
//    on the `Button` and `TextField` to be based on the new `value`, but by now it’s
//    already too late for `onPress` — the old version has already been called!
//
// As you can see, the timing issue introduced by the asynchronous nature of remote-ui
// can cause “old props” to be called from the main thread. This example may seem like
// an unusual pattern, and it is if you are using `@remote-ui/core` directly; you’d generally
// keep a mutable reference to the state, instead of closing over the state with new props.
// However, abstractions on top of `@remote-ui/core`, like the React reconciler in
// `@remote-ui/react`, work almost entirely by closing over state, so this issue is
// much more common with those declarative libraries.
//
// To protect against this, we handle function props a bit differently. When we have a
// function prop, we replace it with a new function that calls the original. However,
// we make the original mutable, by making it a property on the function itself. When
// this function subsequently updates, we don’t send the update to the main thread (as
// we just saw, this can often be "too late" to be of any use). Instead, we swap out
// the mutable reference to the current implementation of the function prop, which can
// be done synchronously. In the example above, this would all happen synchronously in
// the remote context; in our handling of `TextField onChange()`, we update `Button onPress()`,
// and swap out the implementations. Now, when the main thread attempts to call `Button onPress()`,
// it instead calls our wrapper around the function, which can refer to, and call, the
// most recently-applied implementation, instead of directly calling the old implementation.


function tryHotSwappingValues(currentValue, newValue) {
  if (typeof currentValue === 'function' && FUNCTION_CURRENT_IMPLEMENTATION_KEY in currentValue) {
    return [typeof newValue === 'function' ? IGNORE : makeValueHotSwappable(newValue), [[currentValue, newValue]]];
  }

  if (Array.isArray(currentValue)) {
    return tryHotSwappingArrayValues(currentValue, newValue);
  }

  if (_rollupPluginBabelHelpers['typeof'](currentValue) === 'object' && currentValue != null && !utilities.isRemoteFragment(currentValue)) {
    return tryHotSwappingObjectValues(currentValue, newValue);
  }

  return [currentValue === newValue ? IGNORE : newValue];
}

function makeValueHotSwappable(value) {
  if (utilities.isRemoteFragment(value)) {
    return value;
  }

  if (typeof value === 'function') {
    var wrappedFunction = function wrappedFunction() {
      return wrappedFunction[FUNCTION_CURRENT_IMPLEMENTATION_KEY].apply(wrappedFunction, arguments);
    };

    Object.defineProperty(wrappedFunction, FUNCTION_CURRENT_IMPLEMENTATION_KEY, {
      enumerable: false,
      configurable: false,
      writable: true,
      value: value
    });
    return wrappedFunction;
  } else if (Array.isArray(value)) {
    return value.map(makeValueHotSwappable);
  } else if (_rollupPluginBabelHelpers['typeof'](value) === 'object' && value != null) {
    return Object.keys(value).reduce(function (newValue, key) {
      newValue[key] = makeValueHotSwappable(value[key]);
      return newValue;
    }, {});
  }

  return value;
}

function collectNestedHotSwappableValues(value) {
  if (typeof value === 'function') {
    if (FUNCTION_CURRENT_IMPLEMENTATION_KEY in value) return [value];
  } else if (Array.isArray(value)) {
    return value.reduce(function (all, element) {
      var nested = collectNestedHotSwappableValues(element);
      return nested ? [].concat(_rollupPluginBabelHelpers.toConsumableArray(all), _rollupPluginBabelHelpers.toConsumableArray(nested)) : all;
    }, []);
  } else if (_rollupPluginBabelHelpers['typeof'](value) === 'object' && value != null) {
    return Object.keys(value).reduce(function (all, key) {
      var nested = collectNestedHotSwappableValues(value[key]);
      return nested ? [].concat(_rollupPluginBabelHelpers.toConsumableArray(all), _rollupPluginBabelHelpers.toConsumableArray(nested)) : all;
    }, []);
  }
}

function _appendChild(container, child, internals, rootInternals) {
  var nodes = rootInternals.nodes,
      strict = rootInternals.strict;

  if (!nodes.has(child)) {
    throw new Error("Cannot append a node that was not created by this Remote Root");
  }

  return perform(container, rootInternals, {
    remote: function remote(channel) {
      return channel(types.ACTION_INSERT_CHILD, container.id, container.children.length, serializeChild(child));
    },
    local: function local() {
      moveNodeToContainer(container, child, rootInternals);
      var mergedChildren = [].concat(_rollupPluginBabelHelpers.toConsumableArray(internals.children), [child]);
      internals.children = strict ? Object.freeze(mergedChildren) : mergedChildren;
    }
  });
} // there is a problem with this, because when multiple children
// are removed, there is no guarantee the messages will arrive in the
// order we need them to on the host side (it depends how React
// calls our reconciler). If it calls with, for example, the removal of
// the second last item, then the removal of the last item, it will fail
// because the indexes moved around.
//
// Might need to send the removed child ID, or find out if we
// can collect removals into a single update.


function _removeChild(container, child, internals, rootInternals) {
  var strict = rootInternals.strict;
  return perform(container, rootInternals, {
    remote: function remote(channel) {
      return channel(types.ACTION_REMOVE_CHILD, container.id, container.children.indexOf(child));
    },
    local: function local() {
      removeNodeFromContainer(child, rootInternals);

      var newChildren = _rollupPluginBabelHelpers.toConsumableArray(internals.children);

      newChildren.splice(newChildren.indexOf(child), 1);
      internals.children = strict ? Object.freeze(newChildren) : newChildren;
    }
  });
}

function _insertChildBefore(container, child, before, internals, rootInternals) {
  var strict = rootInternals.strict,
      nodes = rootInternals.nodes;

  if (!nodes.has(child)) {
    throw new Error("Cannot insert a node that was not created by this Remote Root");
  }

  return perform(container, rootInternals, {
    remote: function remote(channel) {
      return channel(types.ACTION_INSERT_CHILD, container.id, container.children.indexOf(before), serializeChild(child));
    },
    local: function local() {
      moveNodeToContainer(container, child, rootInternals);

      var newChildren = _rollupPluginBabelHelpers.toConsumableArray(internals.children);

      newChildren.splice(newChildren.indexOf(before), 0, child);
      internals.children = strict ? Object.freeze(newChildren) : newChildren;
    }
  });
}

function normalizeChild(child, root) {
  return typeof child === 'string' ? root.createText(child) : child;
}

function moveNodeToContainer(container, node, rootInternals) {
  var tops = rootInternals.tops,
      parents = rootInternals.parents;
  var newTop = container.kind === types.KIND_ROOT ? container : tops.get(container);
  tops.set(node, newTop);
  parents.set(node, container);
  moveFragmentToContainer(node, rootInternals);
  allDescendants(node, function (descendant) {
    tops.set(descendant, newTop);
    moveFragmentToContainer(descendant, rootInternals);
  });
}

function moveFragmentToContainer(node, rootInternals) {
  if (node.kind !== types.KIND_COMPONENT) return;
  var props = node.props;
  if (!props) return;
  Object.values(props).forEach(function (prop) {
    if (!utilities.isRemoteFragment(prop)) return;
    moveNodeToContainer(node, prop, rootInternals);
  });
}

function removeNodeFromContainer(node, rootInternals) {
  var tops = rootInternals.tops,
      parents = rootInternals.parents;
  tops.delete(node);
  parents.delete(node);
  allDescendants(node, function (descendant) {
    tops.delete(descendant);
    removeFragmentFromContainer(descendant, rootInternals);
  });
  removeFragmentFromContainer(node, rootInternals);
}

function removeFragmentFromContainer(node, rootInternals) {
  if (node.kind !== types.KIND_COMPONENT) return;
  var props = node.remoteProps;

  for (var _i3 = 0, _Object$keys3 = Object.keys(props !== null && props !== void 0 ? props : {}); _i3 < _Object$keys3.length; _i3++) {
    var _key4 = _Object$keys3[_i3];
    var prop = props[_key4];
    if (!utilities.isRemoteFragment(prop)) continue;
    removeNodeFromContainer(prop, rootInternals);
  }
}

function makePartOfTree(node, _ref4) {
  var parents = _ref4.parents,
      tops = _ref4.tops,
      nodes = _ref4.nodes;
  nodes.add(node);
  Object.defineProperty(node, 'parent', {
    get: function get() {
      return parents.get(node);
    },
    configurable: true,
    enumerable: true
  });
  Object.defineProperty(node, 'top', {
    get: function get() {
      return tops.get(node);
    },
    configurable: true,
    enumerable: true
  });
}

function serializeChild(value) {
  return value.kind === types.KIND_TEXT ? {
    id: value.id,
    kind: value.kind,
    text: value.text
  } : {
    id: value.id,
    kind: value.kind,
    type: value.type,
    props: value.remoteProps,
    children: value.children.map(function (child) {
      return serializeChild(child);
    })
  };
}

function serializeProp(prop) {
  if (utilities.isRemoteFragment(prop)) {
    return serializeFragment(prop);
  }

  return prop;
}

function serializeFragment(value) {
  return {
    id: value.id,
    kind: value.kind,

    get children() {
      return value.children.map(function (child) {
        return serializeChild(child);
      });
    }

  };
}

function makeRemote(value, id, root) {
  Object.defineProperty(value, 'id', {
    value: id,
    configurable: true,
    writable: false,
    enumerable: false
  });
  Object.defineProperty(value, 'root', {
    value: root,
    configurable: true,
    writable: false,
    enumerable: false
  });
}

function tryHotSwappingObjectValues(currentValue, newValue) {
  if (_rollupPluginBabelHelpers['typeof'](newValue) !== 'object' || newValue == null) {
    var _collectNestedHotSwap;

    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap === void 0 ? void 0 : _collectNestedHotSwap.map(function (hotSwappable) {
      return [hotSwappable, undefined];
    })];
  }

  var hasChanged = false;
  var hotSwaps = [];
  var normalizedNewValue = {}; // eslint-disable-next-line guard-for-in

  for (var _key5 in currentValue) {
    var currentObjectValue = currentValue[_key5];

    if (!(_key5 in newValue)) {
      hasChanged = true;
      var nestedHotSwappables = collectNestedHotSwappableValues(currentObjectValue);

      if (nestedHotSwappables) {
        hotSwaps.push.apply(hotSwaps, _rollupPluginBabelHelpers.toConsumableArray(nestedHotSwappables.map(function (hotSwappable) {
          return [hotSwappable, undefined];
        })));
      }
    }

    var newObjectValue = newValue[_key5];

    var _tryHotSwappingValues3 = tryHotSwappingValues(currentObjectValue, newObjectValue),
        _tryHotSwappingValues4 = _rollupPluginBabelHelpers.slicedToArray(_tryHotSwappingValues3, 2),
        updatedValue = _tryHotSwappingValues4[0],
        elementHotSwaps = _tryHotSwappingValues4[1];

    if (elementHotSwaps) hotSwaps.push.apply(hotSwaps, _rollupPluginBabelHelpers.toConsumableArray(elementHotSwaps));

    if (updatedValue !== IGNORE) {
      hasChanged = true;
      normalizedNewValue[_key5] = updatedValue;
    }
  }

  for (var _key6 in newValue) {
    if (_key6 in normalizedNewValue) continue;
    hasChanged = true;
    normalizedNewValue[_key6] = makeValueHotSwappable(newValue[_key6]);
  }

  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];
}

function tryHotSwappingArrayValues(currentValue, newValue) {
  if (!Array.isArray(newValue)) {
    var _collectNestedHotSwap2;

    return [makeValueHotSwappable(newValue), (_collectNestedHotSwap2 = collectNestedHotSwappableValues(currentValue)) === null || _collectNestedHotSwap2 === void 0 ? void 0 : _collectNestedHotSwap2.map(function (hotSwappable) {
      return [hotSwappable, undefined];
    })];
  }

  var hasChanged = false;
  var hotSwaps = [];
  var newLength = newValue.length;
  var currentLength = currentValue.length;
  var maxLength = Math.max(currentLength, newLength);
  var normalizedNewValue = [];

  for (var i = 0; i < maxLength; i++) {
    var currentArrayValue = currentValue[i];
    var newArrayValue = newValue[i];

    if (i < newLength) {
      if (i >= currentLength) {
        hasChanged = true;
        normalizedNewValue[i] = makeValueHotSwappable(newArrayValue);
        continue;
      }

      var _tryHotSwappingValues5 = tryHotSwappingValues(currentArrayValue, newArrayValue),
          _tryHotSwappingValues6 = _rollupPluginBabelHelpers.slicedToArray(_tryHotSwappingValues5, 2),
          updatedValue = _tryHotSwappingValues6[0],
          elementHotSwaps = _tryHotSwappingValues6[1];

      if (elementHotSwaps) hotSwaps.push.apply(hotSwaps, _rollupPluginBabelHelpers.toConsumableArray(elementHotSwaps));

      if (updatedValue === IGNORE) {
        normalizedNewValue[i] = currentArrayValue;
        continue;
      }

      hasChanged = true;
      normalizedNewValue[i] = updatedValue;
    } else {
      hasChanged = true;
      var nestedHotSwappables = collectNestedHotSwappableValues(currentArrayValue);

      if (nestedHotSwappables) {
        hotSwaps.push.apply(hotSwaps, _rollupPluginBabelHelpers.toConsumableArray(nestedHotSwappables.map(function (hotSwappable) {
          return [hotSwappable, undefined];
        })));
      }
    }
  }

  return [hasChanged ? normalizedNewValue : IGNORE, hotSwaps];
}

exports.createRemoteRoot = createRemoteRoot;
