import { createForOfIteratorHelper as _createForOfIteratorHelper, slicedToArray as _slicedToArray, objectSpread2 as _objectSpread2, toConsumableArray as _toConsumableArray } from './_virtual/_rollupPluginBabelHelpers.js';
import { retain, release } from '@remote-ui/rpc';
import { KIND_COMPONENT, KIND_FRAGMENT, ACTION_MOUNT, ACTION_REMOVE_CHILD, ACTION_INSERT_CHILD, ACTION_UPDATE_PROPS, ACTION_UPDATE_TEXT } from './types.mjs';
import { isRemoteFragment } from './utilities.mjs';

var ROOT_ID = Symbol('RootId');
function createRemoteChannel(_ref) {
  var mount = _ref.mount,
      insertChild = _ref.insertChild,
      removeChild = _ref.removeChild,
      updateProps = _ref.updateProps,
      updateText = _ref.updateText;
  var messageMap = new Map([[ACTION_MOUNT, mount], [ACTION_REMOVE_CHILD, removeChild], [ACTION_INSERT_CHILD, insertChild], [ACTION_UPDATE_PROPS, updateProps], [ACTION_UPDATE_TEXT, updateText]]);
  return function (type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return messageMap.get(type).apply(void 0, args);
  };
}
function createRemoteReceiver() {
  var queuedUpdates = new Set();
  var listeners = new Map();
  var attachmentSubscribers = new Map();
  var timeout = null;
  var state = 'unmounted';
  var root = {
    id: ROOT_ID,
    children: [],
    version: 0
  };
  var attachedNodes = new Map([[ROOT_ID, root]]);
  var receive = createRemoteChannel({
    mount: function mount(children) {
      var root = attachedNodes.get(ROOT_ID);
      var normalizedChildren = children.map(function (child) {
        return normalizeNode(child, addVersion);
      });
      root.version += 1;
      root.children = normalizedChildren;
      state = 'mounted';

      var _iterator = _createForOfIteratorHelper(normalizedChildren),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          retain(child);
          attach(child);
        } // eslint-disable-next-line promise/catch-or-return

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      enqueueUpdate(root).then(function () {
        emit('mount');
      });
    },
    insertChild: function insertChild(id, index, child) {
      var attached = attachedNodes.get(id !== null && id !== void 0 ? id : ROOT_ID);
      var normalizedChild = normalizeNode(child, addVersion);
      retain(normalizedChild);
      attach(normalizedChild);
      var children = attached.children;

      if (index === children.length) {
        children.push(normalizedChild);
      } else {
        children.splice(index, 0, normalizedChild);
      }

      attached.version += 1;
      enqueueUpdate(attached);
    },
    removeChild: function removeChild(id, index) {
      var attached = attachedNodes.get(id !== null && id !== void 0 ? id : ROOT_ID);
      var children = attached.children;

      var _children$splice = children.splice(index, 1),
          _children$splice2 = _slicedToArray(_children$splice, 1),
          removed = _children$splice2[0];

      attached.version += 1;
      detach(removed); // eslint-disable-next-line promise/catch-or-return

      enqueueUpdate(attached).then(function () {
        release(removed);
      });
    },
    updateProps: function updateProps(id, newProps) {
      var component = attachedNodes.get(id);

      var oldProps = _objectSpread2({}, component.props);

      retain(newProps);
      Object.keys(newProps).forEach(function (key) {
        var newProp = newProps[key];
        var oldProp = oldProps[key];

        if (isRemoteReceiverAttachableFragment(oldProp)) {
          detach(oldProp);
        }

        if (isRemoteFragmentSerialization(newProp)) {
          var attachableNewProp = addVersion(newProp);
          attach(attachableNewProp);
        }
      });
      Object.assign(component.props, newProps);
      component.version += 1; // eslint-disable-next-line promise/catch-or-return

      enqueueUpdate(component).then(function () {
        for (var _i = 0, _Object$keys = Object.keys(newProps); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          release(oldProps[key]);
        }
      });
    },
    updateText: function updateText(id, newText) {
      var text = attachedNodes.get(id);
      text.text = newText;
      text.version += 1;
      enqueueUpdate(text);
    }
  });
  return {
    get state() {
      return state;
    },

    receive: receive,
    attached: {
      root: root,
      get: function get(_ref2) {
        var _ref3;

        var id = _ref2.id;
        return (_ref3 = attachedNodes.get(id)) !== null && _ref3 !== void 0 ? _ref3 : null;
      },
      subscribe: function subscribe(_ref4, subscriber) {
        var id = _ref4.id;
        var subscribers = attachmentSubscribers.get(id);

        if (subscribers == null) {
          subscribers = new Set();
          attachmentSubscribers.set(id, subscribers);
        }

        subscribers.add(subscriber);
        return function () {
          var subscribers = attachmentSubscribers.get(id);

          if (subscribers) {
            subscribers.delete(subscriber);

            if (subscribers.size === 0) {
              attachmentSubscribers.delete(id);
            }
          }
        };
      }
    },
    flush: flush,
    on: function on(event, listener) {
      var listenersForEvent = listeners.get(event);

      if (listenersForEvent == null) {
        listenersForEvent = new Set();
        listeners.set(event, listenersForEvent);
      }

      listenersForEvent.add(listener);
      return function () {
        var listenersForEvent = listeners.get(event);

        if (listenersForEvent) {
          listenersForEvent.delete(listener);

          if (listenersForEvent.size === 0) {
            listeners.delete(event);
          }
        }
      };
    }
  };

  function flush() {
    var _timeout;

    return (_timeout = timeout) !== null && _timeout !== void 0 ? _timeout : Promise.resolve();
  }

  function emit(event) {
    var listenersForEvent = listeners.get(event);

    if (listenersForEvent) {
      var _iterator2 = _createForOfIteratorHelper(listenersForEvent),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;
          listener();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }

  function enqueueUpdate(attached) {
    var _timeout2;

    timeout = (_timeout2 = timeout) !== null && _timeout2 !== void 0 ? _timeout2 : new Promise(function (resolve) {
      setTimeout(function () {
        var attachedToUpdate = _toConsumableArray(queuedUpdates);

        timeout = null;
        queuedUpdates.clear();

        var _iterator3 = _createForOfIteratorHelper(attachedToUpdate),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _attached = _step3.value;
            var subscribers = attachmentSubscribers.get(_attached.id);

            if (subscribers) {
              var _iterator4 = _createForOfIteratorHelper(subscribers),
                  _step4;

              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var _subscriber = _step4.value;

                  _subscriber(_attached);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        resolve();
      }, 0);
    });
    queuedUpdates.add(attached);
    return timeout;
  }

  function attach(child) {
    attachedNodes.set(child.id, child);

    if (child.kind === KIND_COMPONENT && 'props' in child) {
      var _ref5 = child,
          _ref5$props = _ref5.props,
          props = _ref5$props === void 0 ? {} : _ref5$props;
      Object.keys(props).forEach(function (key) {
        var prop = props[key];
        if (!isRemoteReceiverAttachableFragment(prop)) return;
        attach(prop);
      });
    }

    if ('children' in child) {
      var _iterator5 = _createForOfIteratorHelper(child.children),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var grandChild = _step5.value;
          attach(grandChild);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  }

  function detach(child) {
    attachedNodes.delete(child.id);

    if (child.kind === KIND_COMPONENT && 'props' in child) {
      var _ref6 = child,
          _ref6$props = _ref6.props,
          props = _ref6$props === void 0 ? {} : _ref6$props;
      Object.keys(props).forEach(function (key) {
        var prop = props[key];
        if (!isRemoteReceiverAttachableFragment(prop)) return;
        detach(prop);
      });
    }

    if ('children' in child) {
      var _iterator6 = _createForOfIteratorHelper(child.children),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var grandChild = _step6.value;
          detach(grandChild);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }
}

function addVersion(value) {
  value.version = 0;
  return value;
}

function normalizeNode(node, normalizer) {
  if (node.kind === KIND_FRAGMENT || node.kind === KIND_COMPONENT) {
    node.children.forEach(function (child) {
      return normalizeNode(child, normalizer);
    });
  }

  if (node.kind === KIND_COMPONENT && 'props' in node) {
    var _ref7 = node,
        props = _ref7.props;

    for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      var prop = props[key];
      if (!isRemoteFragmentSerialization(prop)) continue;
      props[key] = normalizeNode(prop, normalizer);
    }
  }

  return normalizer(node);
}

function isRemoteFragmentSerialization(object) {
  return isRemoteFragment(object) && 'id' in object && 'children' in object;
}
function isRemoteReceiverAttachableFragment(object) {
  return isRemoteFragmentSerialization(object) && 'version' in object;
}

export { ROOT_ID, createRemoteChannel, createRemoteReceiver, isRemoteFragmentSerialization, isRemoteReceiverAttachableFragment };
