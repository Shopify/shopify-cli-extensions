import { objectWithoutProperties as _objectWithoutProperties, createForOfIteratorHelper as _createForOfIteratorHelper } from './_virtual/_rollupPluginBabelHelpers.js';
import reactReconciler from 'react-reconciler';

var reconciler = reactReconciler({
  now: Date.now,
  // Timeout
  scheduleTimeout: setTimeout,
  cancelTimeout: clearTimeout,
  noTimeout: false,
  // @see https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMHostConfig.js#L408
  queueMicrotask: function queueMicrotask(callback) {
    return Promise.resolve(null).then(callback).catch(handleErrorInNextTick);
  },
  isPrimaryRenderer: true,
  supportsMutation: true,
  supportsHydration: false,
  supportsPersistence: false,
  // Context
  getRootHostContext: function getRootHostContext() {
    return {};
  },
  getChildHostContext: function getChildHostContext(context) {
    return context;
  },
  // Instances
  createTextInstance: function createTextInstance(text, root) {
    return root.createText(text);
  },
  createInstance: function createInstance(type, allProps, root) {
    allProps.children;
        var props = _objectWithoutProperties(allProps, ["children"]);

    return root.createComponent(type, props);
  },
  // Updates
  commitTextUpdate: function commitTextUpdate(text, _oldText, newText) {
    text.updateText(newText);
  },
  prepareUpdate: function prepareUpdate(_instance, _type, oldProps, newProps) {
    var updateProps = {};
    var needsUpdate = false;

    for (var key in oldProps) {
      if (!has(oldProps, key) || key === 'children') {
        continue;
      }

      if (!(key in newProps)) {
        needsUpdate = true;
        updateProps[key] = undefined; // } else if (typeof oldProps[key] === 'function') {
        //   if (typeof newProps[key] === 'function') {
        //     fragment.controller.functions.exchange(
        //       oldProps[key] as Function,
        //       newProps[key] as Function,
        //     );
        //   } else {
        //     needsUpdate = true;
        //     fragment.controller.functions.revoke(oldProps[key] as Function);
        //     updateProps[key] = newProps[key];
        //   }
      } else if (oldProps[key] !== newProps[key]) {
        needsUpdate = true;
        updateProps[key] = newProps[key];
      }
    }

    for (var _key in newProps) {
      if (!has(newProps, _key) || _key === 'children') {
        continue;
      }

      if (!(_key in oldProps)) {
        needsUpdate = true;
        updateProps[_key] = newProps[_key];
      }
    }

    return needsUpdate ? updateProps : null;
  },
  commitUpdate: function commitUpdate(instance, payload) {
    instance.updateProps(payload);
  },
  // Update root
  appendChildToContainer: function appendChildToContainer(remoteRoot, child) {
    remoteRoot.appendChild(child);
  },
  insertInContainerBefore: function insertInContainerBefore(remoteRoot, child, beforeChild) {
    remoteRoot.insertChildBefore(child, beforeChild);
  },
  removeChildFromContainer: function removeChildFromContainer(remoteRoot, child) {
    remoteRoot.removeChild(child);
  },
  clearContainer: function clearContainer(remoteRoot) {
    var _iterator = _createForOfIteratorHelper(remoteRoot.children),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        remoteRoot.removeChild(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  },
  // Update children
  appendInitialChild: function appendInitialChild(parent, child) {
    parent.appendChild(child);
  },
  appendChild: function appendChild(parent, child) {
    parent.appendChild(child);
  },
  insertBefore: function insertBefore(parent, newChild, beforeChild) {
    parent.insertChildBefore(newChild, beforeChild);
  },
  removeChild: function removeChild(parent, child) {
    parent.removeChild(child);
  },
  // Unknown
  finalizeInitialChildren: function finalizeInitialChildren() {
    return false;
  },
  shouldSetTextContent: function shouldSetTextContent() {
    return false;
  },
  getPublicInstance: function getPublicInstance() {},
  prepareForCommit: function prepareForCommit() {
    return null;
  },
  resetAfterCommit: function resetAfterCommit() {},
  commitMount: function commitMount() {},
  preparePortalMount: function preparePortalMount() {}
});

function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}

var _ref = {},
    hasOwnProperty = _ref.hasOwnProperty;

function has(object, property) {
  return hasOwnProperty.call(object, property);
}

export default reconciler;
