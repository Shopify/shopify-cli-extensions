"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteReactComponent = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const core_1 = require("@remote-ui/core");
const hooks_1 = require("./hooks");
function createRemoteReactComponent(componentType, { fragmentProps } = {}) {
    if (!fragmentProps || !fragmentProps.length) {
        return componentType;
    }
    const wrapper = createComponentWrapper(componentType, fragmentProps);
    wrapper.displayName = componentType;
    return wrapper;
}
exports.createRemoteReactComponent = createRemoteReactComponent;
function createComponentWrapper(componentType, fragmentProps) {
    const Component = componentType;
    return react_1.memo(function ComponentWrapper(_a) {
        var { children: externalChildren = [] } = _a, externalProps = __rest(_a, ["children"]);
        const fragments = react_1.useRef({});
        const { root, reconciler } = hooks_1.useRender();
        const { props, children } = react_1.useMemo(() => {
            // React portals need to be attached to the tree after intialize in order to render.
            // It's usually done by appending them as children of a parent node.
            // @see https://reactjs.org/docs/portals.html
            const portals = [];
            const props = {};
            for (const key of Object.keys(externalProps)) {
                const element = externalProps[key];
                if (fragmentProps.includes(key) && react_1.isValidElement(element)) {
                    const currentFragment = fragments.current[key];
                    const fragment = core_1.isRemoteFragment(currentFragment)
                        ? currentFragment
                        : root.createFragment();
                    fragments.current[key] = fragment;
                    // Assign createText and createComponent to fragment
                    // so that it can become a React container to render the portal
                    Object.assign(fragment, {
                        createText(...args) {
                            return root.createText(...args);
                        },
                        createComponent(type, ...args) {
                            return root.createComponent(type, ...args);
                        },
                    });
                    const portal = reconciler.createPortal(element, fragment, null, null);
                    portals.push(portal);
                    props[key] = fragment;
                }
                else {
                    props[key] = element;
                    delete fragments.current[key];
                }
            }
            return { props, children: [...externalChildren, ...portals] };
        }, [externalChildren, externalProps, root, reconciler, fragments]);
        return jsx_runtime_1.jsx(Component, Object.assign({}, props, { children: children }), void 0);
    });
}
