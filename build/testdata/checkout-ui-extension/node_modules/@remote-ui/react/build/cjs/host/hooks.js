'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');
var react = require('react');
var context = require('./context.js');

function useRemoteReceiver() {
  var receiver = react.useContext(context.RemoteReceiverContext);

  if (receiver == null) {
    throw new Error('No remote-ui Receiver instance found in context');
  }

  return receiver;
}
function useAttached(receiver, attached) {
  var _useState = react.useState({
    receiver: receiver,
    id: attached.id,
    version: attached.version,
    value: attached
  }),
      _useState2 = _rollupPluginBabelHelpers.slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var returnValue = state.value; // If parameters have changed since our last render, schedule an update with its current value.

  if (state.receiver !== receiver || state.id !== attached.id) {
    // When the consumer of this hook changes receiver or attached node, the node they switched
    // to might already be unmounted. We guard against that by making sure we don’t get null
    // back from the receiver, and storing the “attached” node in state whether it is actually
    // attached or not, so we have a paper trail of how we got here.
    var updated = receiver.attached.get(attached); // If the subscription has been updated, we'll schedule another update with React.
    // React will process this update immediately, so the old subscription value won't be committed.
    // It is still nice to avoid returning a mismatched value though, so let's override the return value.

    returnValue = updated;
    setState({
      receiver: receiver,
      id: attached.id,
      version: attached.version,
      value: returnValue
    });
  }

  react.useDebugValue(returnValue);
  react.useEffect(function () {
    var didUnsubscribe = false;

    var checkForUpdates = function checkForUpdates() {
      if (didUnsubscribe) return;
      setState(function (previousState) {
        var previousId = previousState.id,
            previousVersion = previousState.version,
            previousReceiver = previousState.receiver;
        var id = attached.id; // Ignore values from stale sources

        if (previousReceiver !== receiver || previousId !== id) {
          return previousState;
        } // This function is also called as part of the initial useEffect() when the
        // component mounts. It’s possible that between the initial render (when the
        // remote component was for sure attached, to the best of the host’s knowledge)
        // and the effect, the component was removed from the remote tree. You’ll see that
        // the rest of this callback is careful to handle cases where the node is in this
        // state.


        var value = receiver.attached.get(attached);
        var version = value === null || value === void 0 ? void 0 : value.version; // If the value hasn't changed, no update is needed.
        // Return state as-is so React can bail out and avoid an unnecessary render.

        if (previousVersion === version) {
          return previousState;
        }

        return {
          receiver: receiver,
          value: value,
          id: id,
          version: version
        };
      });
    };

    var unsubscribe = receiver.attached.subscribe(attached, checkForUpdates); // Passive effect, so we need to check if anything has changed

    checkForUpdates();
    return function () {
      didUnsubscribe = true;
      unsubscribe();
    };
  }, [receiver, attached]);
  return returnValue;
}

exports.useAttached = useAttached;
exports.useRemoteReceiver = useRemoteReceiver;
