"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PACKAGES_TO_PROCESS = void 0;
const path_1 = require("path");
const vm_1 = require("vm");
exports.DEFAULT_PACKAGES_TO_PROCESS = {
    '@remote-ui/web-workers': [
        { name: 'createPlainWorkerFactory' },
        {
            name: 'createWorkerFactory',
            wrapperModule: path_1.resolve(__dirname, 'wrappers/expose.js.raw'),
        },
    ],
};
const loader = path_1.resolve(__dirname, 'webpack-parts/loader');
function workerBabelPlugin({ types: t, template, }) {
    const noopBinding = template(`() => (
      new Proxy(
        {},
        {
          get() {
            return () => {
              throw new Error('You can’t call a method on a noop worker');
            };
          },
        },
      )
    );`, { sourceType: 'module' });
    return {
        visitor: {
            Program(program, state) {
                var _a;
                state.program = program;
                const packages = ((_a = state.opts) === null || _a === void 0 ? void 0 : _a.packages)
                    ? normalize(state.opts.packages)
                    : exports.DEFAULT_PACKAGES_TO_PROCESS;
                state.process = new Map(Object.entries(packages));
            },
            ImportDeclaration(importDeclaration, state) {
                const processImports = state.process.get(importDeclaration.node.source.value);
                if (processImports == null) {
                    return;
                }
                for (const specifier of importDeclaration.get('specifiers')) {
                    if (!specifier.isImportSpecifier() ||
                        specifier.node.imported.type !== 'Identifier') {
                        continue;
                    }
                    const importedName = specifier.node.imported.name;
                    const processableImport = processImports.find(({ name }) => name === importedName);
                    if (processableImport == null) {
                        continue;
                    }
                    const binding = specifier.scope.getBinding(specifier.node.imported.name);
                    if (binding == null) {
                        continue;
                    }
                    processBinding(binding, processableImport, state);
                }
            },
        },
    };
    function processBinding(binding, importOptions, state) {
        const { program, opts: options = {} } = state;
        const { noop = false } = options;
        const callingReferences = binding.referencePaths.filter((referencePath) => referencePath.parentPath.isCallExpression());
        for (const referencePath of callingReferences) {
            const callExpression = referencePath.parentPath;
            const dynamicImports = new Set();
            const firstArgument = callExpression.get('arguments')[0];
            firstArgument.traverse({
                Import({ parentPath }) {
                    if (parentPath.isCallExpression()) {
                        dynamicImports.add(parentPath);
                    }
                },
            });
            if (dynamicImports.size === 0) {
                return;
            }
            if (dynamicImports.size > 1) {
                throw new Error('You made more than one dynamic import in the body of a web worker create function. Only one such import is allowed.');
            }
            const dynamicallyImported = [...dynamicImports][0].get('arguments')[0];
            const { value: imported, confident } = dynamicallyImported.evaluate();
            if (typeof imported !== 'string' || !confident) {
                throw new Error(`Failed to evaluate a dynamic import to a string to create a web worker (${dynamicallyImported.getSource()})`);
            }
            if (noop) {
                firstArgument.replaceWith(noopBinding());
                return;
            }
            const { leadingComments } = dynamicallyImported.node;
            const options = Object.assign(Object.assign({}, getLoaderOptions(leadingComments || [])), { wrapperModule: importOptions.wrapperModule });
            const importId = callExpression.scope.generateUidIdentifier('worker');
            program
                .get('body')[0]
                .insertBefore(t.importDeclaration([t.importDefaultSpecifier(importId)], t.stringLiteral(`${loader}?${JSON.stringify(options)}!${imported}`)));
            firstArgument.replaceWith(importId);
        }
    }
}
exports.default = workerBabelPlugin;
// Reduced replication of webpack’s logic for parsing import comments:
// https://github.com/webpack/webpack/blob/5147aed90ec8cd3633b0c45583f02afd16c7888d/lib/JavascriptParser.js#L2799-L2820
const webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);
function getLoaderOptions(comments) {
    return comments.reduce((options, comment) => {
        const { value } = comment;
        if (!value || !webpackCommentRegExp.test(value)) {
            return options;
        }
        try {
            const { webpackChunkName: name } = vm_1.runInNewContext(`(function(){return {${value}};})()`);
            return name ? Object.assign(Object.assign({}, options), { name }) : options;
        }
        catch (_a) {
            return options;
        }
    }, {});
}
function normalize(packages) {
    return Object.keys(packages).reduce((all, pkg) => (Object.assign(Object.assign({}, all), { [pkg]: packages[pkg].map((anImport) => typeof anImport === 'string' ? { name: anImport } : anImport) })), {});
}
