"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pitch = void 0;
const path = __importStar(require("path"));
const loader_utils_1 = require("loader-utils");
// @ts-ignore
const SingleEntryPlugin_1 = __importDefault(require("webpack/lib/SingleEntryPlugin"));
// @ts-ignore
const WebWorkerTemplatePlugin_1 = __importDefault(require("webpack/lib/webworker/WebWorkerTemplatePlugin"));
// @ts-ignore
const FetchCompileWasmTemplatePlugin_1 = __importDefault(require("webpack/lib/web/FetchCompileWasmTemplatePlugin"));
const plugin_1 = require("./plugin");
const NAME = 'WebWorker';
const moduleWrapperCache = new Map();
function pitch(request) {
    var _a;
    this.cacheable(false);
    const callback = this.async();
    const { context, resourcePath, _compiler: compiler, _compilation: compilation, } = this;
    if (compiler.options.output.globalObject !== 'self') {
        return callback(new Error('webpackConfig.output.globalObject is not set to "self", which will cause chunk loading in the worker to fail. Please change the value to "self" for any builds targeting the browser, or set the {noop: true} option on the @remote-ui/web-workers babel plugin.'));
    }
    const plugin = (compiler.options.plugins || []).find(plugin_1.WebWorkerPlugin.isInstance);
    if (plugin == null) {
        throw new Error('You must also include the WebWorkerPlugin from `@remote-ui/web-workers` when using the Babel plugin.');
    }
    const options = loader_utils_1.getOptions(this) || {};
    const { name = String(plugin.workerId++), wrapperModule } = options;
    const virtualModule = path.join(path.dirname(resourcePath), `${path.basename(resourcePath, path.extname(resourcePath))}.worker.js`);
    let wrapperContent;
    if (wrapperModule) {
        this.addDependency(wrapperModule);
        const cachedContent = moduleWrapperCache.get(wrapperModule);
        if (typeof cachedContent === 'string') {
            wrapperContent = cachedContent;
        }
        else if (cachedContent == null) {
            try {
                wrapperContent = this.fs.readFileSync(wrapperModule).toString();
                moduleWrapperCache.set(wrapperModule, wrapperContent !== null && wrapperContent !== void 0 ? wrapperContent : false);
            }
            catch (error) {
                moduleWrapperCache.set(wrapperModule, false);
            }
        }
    }
    if (wrapperContent) {
        plugin.virtualModules.writeModule(virtualModule, wrapperContent.replace('{{WORKER_MODULE}}', JSON.stringify(request)));
    }
    const workerOptions = {
        filename: (_a = plugin.options.filename) !== null && _a !== void 0 ? _a : addWorkerSubExtension(compiler.options.output.filename),
        chunkFilename: addWorkerSubExtension(compiler.options.output.chunkFilename),
        globalObject: (plugin && plugin.options.globalObject) || 'self',
    };
    const workerCompiler = compilation.createChildCompiler(NAME, workerOptions, []);
    workerCompiler.context = compiler.context;
    new WebWorkerTemplatePlugin_1.default({}).apply(workerCompiler);
    new FetchCompileWasmTemplatePlugin_1.default({
        mangleImports: compiler.options.optimization.mangleWasmImports,
    }).apply(workerCompiler);
    new SingleEntryPlugin_1.default(context, wrapperContent == null ? request : virtualModule, name).apply(workerCompiler);
    for (const aPlugin of plugin.options.plugins || []) {
        aPlugin.apply(workerCompiler);
    }
    const subCache = `subcache ${__dirname} ${request}`;
    workerCompiler.hooks.compilation.tap(NAME, (compilation) => {
        if (!compilation.cache) {
            return;
        }
        if (!compilation.cache[subCache]) {
            compilation.cache[subCache] = {};
        }
        compilation.cache = compilation.cache[subCache];
    });
    workerCompiler.runAsChild((error, entries, compilation) => {
        let finalError;
        if (!error && compilation.errors && compilation.errors.length) {
            finalError = compilation.errors[0];
        }
        const entry = entries && entries[0] && entries[0].files[0];
        if (!finalError && !entry) {
            finalError = new Error(`WorkerPlugin: no entry for ${request}`);
        }
        if (finalError) {
            return callback(finalError);
        }
        return callback(null, `export default __webpack_public_path__ + ${JSON.stringify(entry)};`);
    });
}
exports.pitch = pitch;
function addWorkerSubExtension(file) {
    return file.includes('[name]')
        ? file.replace(/\.([a-z]+)$/i, '.worker.$1')
        : file.replace(/\.([a-z]+)$/i, '.[name].worker.$1');
}
const loader = {
    pitch,
};
exports.default = loader;
