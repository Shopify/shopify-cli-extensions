"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEndpoint = exports.terminate = exports.expose = exports.createWorkerFactory = void 0;
const rpc_1 = require("@remote-ui/rpc");
const messenger_1 = require("../messenger");
const utilities_1 = require("./utilities");
const workerEndpointCache = new WeakMap();
function createWorkerFactory(script) {
    const scriptUrl = utilities_1.createScriptUrl(script);
    function createWorker(_a = {}) {
        var { createMessenger = messenger_1.createWorkerMessenger } = _a, endpointOptions = __rest(_a, ["createMessenger"]);
        if (scriptUrl) {
            const endpoint = rpc_1.createEndpoint(createMessenger(scriptUrl), endpointOptions);
            const { call: caller } = endpoint;
            workerEndpointCache.set(caller, endpoint);
            return caller;
        }
        // The babel plugin that comes with this package actually turns the argument
        // into a string (the public path of the worker script). If it’s a function,
        // it’s because we’re in an environment where we didn’t transform it into a
        // worker. In that case, we can use the fact that we will get access to the
        // real module and pretend to be a worker that way.
        if (typeof script === 'function') {
            return new Proxy({}, {
                get(_target, property) {
                    return async (...args) => {
                        const module = await script();
                        return module[property](...args);
                    };
                },
            });
        }
        // If we aren’t in an environment that supports Workers, just bail out
        // with a dummy worker that throws for every method call.
        if (typeof window === 'undefined') {
            return new Proxy({}, {
                get(_target, _property) {
                    return () => {
                        throw new Error('You can’t call a method on a worker on the server.');
                    };
                },
            });
        }
        throw new Error('Could not create a suitable fallback');
    }
    Reflect.defineProperty(createWorker, 'url', {
        value: scriptUrl,
    });
    return createWorker;
}
exports.createWorkerFactory = createWorkerFactory;
function expose(caller, api) {
    const endpoint = getEndpoint(caller);
    endpoint === null || endpoint === void 0 ? void 0 : endpoint.expose(api);
    return endpoint != null;
}
exports.expose = expose;
function terminate(caller) {
    const endpoint = getEndpoint(caller);
    endpoint === null || endpoint === void 0 ? void 0 : endpoint.terminate();
    workerEndpointCache.delete(caller);
    return endpoint != null;
}
exports.terminate = terminate;
function getEndpoint(caller) {
    return workerEndpointCache.get(caller);
}
exports.getEndpoint = getEndpoint;
