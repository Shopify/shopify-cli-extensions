'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');
var path = require('path');
var loaderUtils = require('loader-utils');
var SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');
var WebWorkerTemplatePlugin = require('webpack/lib/webworker/WebWorkerTemplatePlugin');
var FetchCompileWasmTemplatePlugin = require('webpack/lib/web/FetchCompileWasmTemplatePlugin');
var plugin = require('./plugin.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var SingleEntryPlugin__default = /*#__PURE__*/_interopDefaultLegacy(SingleEntryPlugin);
var WebWorkerTemplatePlugin__default = /*#__PURE__*/_interopDefaultLegacy(WebWorkerTemplatePlugin);
var FetchCompileWasmTemplatePlugin__default = /*#__PURE__*/_interopDefaultLegacy(FetchCompileWasmTemplatePlugin);

var NAME = 'WebWorker';
var moduleWrapperCache = new Map();
function pitch(request) {
  var _plugin$options$filen;

  this.cacheable(false);
  var callback = this.async();
  var context = this.context,
      resourcePath = this.resourcePath,
      compiler = this._compiler,
      compilation = this._compilation;

  if (compiler.options.output.globalObject !== 'self') {
    return callback(new Error('webpackConfig.output.globalObject is not set to "self", which will cause chunk loading in the worker to fail. Please change the value to "self" for any builds targeting the browser, or set the {noop: true} option on the @remote-ui/web-workers babel plugin.'));
  }

  var plugin$1 = (compiler.options.plugins || []).find(plugin.WebWorkerPlugin.isInstance);

  if (plugin$1 == null) {
    throw new Error('You must also include the WebWorkerPlugin from `@remote-ui/web-workers` when using the Babel plugin.');
  }

  var options = loaderUtils.getOptions(this) || {};
  var _options$name = options.name,
      name = _options$name === void 0 ? String(plugin$1.workerId++) : _options$name,
      wrapperModule = options.wrapperModule;
  var virtualModule = path__namespace.join(path__namespace.dirname(resourcePath), "".concat(path__namespace.basename(resourcePath, path__namespace.extname(resourcePath)), ".worker.js"));
  var wrapperContent;

  if (wrapperModule) {
    this.addDependency(wrapperModule);
    var cachedContent = moduleWrapperCache.get(wrapperModule);

    if (typeof cachedContent === 'string') {
      wrapperContent = cachedContent;
    } else if (cachedContent == null) {
      try {
        var _wrapperContent;

        wrapperContent = this.fs.readFileSync(wrapperModule).toString();
        moduleWrapperCache.set(wrapperModule, (_wrapperContent = wrapperContent) !== null && _wrapperContent !== void 0 ? _wrapperContent : false);
      } catch (error) {
        moduleWrapperCache.set(wrapperModule, false);
      }
    }
  }

  if (wrapperContent) {
    plugin$1.virtualModules.writeModule(virtualModule, wrapperContent.replace('{{WORKER_MODULE}}', JSON.stringify(request)));
  }

  var workerOptions = {
    filename: (_plugin$options$filen = plugin$1.options.filename) !== null && _plugin$options$filen !== void 0 ? _plugin$options$filen : addWorkerSubExtension(compiler.options.output.filename),
    chunkFilename: addWorkerSubExtension(compiler.options.output.chunkFilename),
    globalObject: plugin$1 && plugin$1.options.globalObject || 'self'
  };
  var workerCompiler = compilation.createChildCompiler(NAME, workerOptions, []);
  workerCompiler.context = compiler.context;
  new WebWorkerTemplatePlugin__default['default']({}).apply(workerCompiler);
  new FetchCompileWasmTemplatePlugin__default['default']({
    mangleImports: compiler.options.optimization.mangleWasmImports
  }).apply(workerCompiler);
  new SingleEntryPlugin__default['default'](context, wrapperContent == null ? request : virtualModule, name).apply(workerCompiler);

  var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(plugin$1.options.plugins || []),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var aPlugin = _step.value;
      aPlugin.apply(workerCompiler);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var subCache = "subcache ".concat(__dirname, " ").concat(request);
  workerCompiler.hooks.compilation.tap(NAME, function (compilation) {
    if (!compilation.cache) {
      return;
    }

    if (!compilation.cache[subCache]) {
      compilation.cache[subCache] = {};
    }

    compilation.cache = compilation.cache[subCache];
  });
  workerCompiler.runAsChild(function (error, entries, compilation) {
    var finalError;

    if (!error && compilation.errors && compilation.errors.length) {
      finalError = compilation.errors[0];
    }

    var entry = entries && entries[0] && entries[0].files[0];

    if (!finalError && !entry) {
      finalError = new Error("WorkerPlugin: no entry for ".concat(request));
    }

    if (finalError) {
      return callback(finalError);
    }

    return callback(null, "export default __webpack_public_path__ + ".concat(JSON.stringify(entry), ";"));
  });
}

function addWorkerSubExtension(file) {
  return file.includes('[name]') ? file.replace(/\.([a-z]+)$/i, '.worker.$1') : file.replace(/\.([a-z]+)$/i, '.[name].worker.$1');
}

var loader = {
  pitch: pitch
};

exports.default = loader;
exports.pitch = pitch;
