import { objectWithoutProperties as _objectWithoutProperties, asyncToGenerator as _asyncToGenerator } from '../_virtual/_rollupPluginBabelHelpers.js';
import { createEndpoint } from '@remote-ui/rpc';
import { createScriptUrl } from './utilities.mjs';
import { createWorkerMessenger } from '../messenger/worker.mjs';

var workerEndpointCache = new WeakMap();
function createWorkerFactory(script) {
  var scriptUrl = createScriptUrl(script);

  function createWorker() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$createMessenger = _ref.createMessenger,
        createMessenger = _ref$createMessenger === void 0 ? createWorkerMessenger : _ref$createMessenger,
        endpointOptions = _objectWithoutProperties(_ref, ["createMessenger"]);

    if (scriptUrl) {
      var endpoint = createEndpoint(createMessenger(scriptUrl), endpointOptions);
      var caller = endpoint.call;
      workerEndpointCache.set(caller, endpoint);
      return caller;
    } // The babel plugin that comes with this package actually turns the argument
    // into a string (the public path of the worker script). If it’s a function,
    // it’s because we’re in an environment where we didn’t transform it into a
    // worker. In that case, we can use the fact that we will get access to the
    // real module and pretend to be a worker that way.


    if (typeof script === 'function') {
      return new Proxy({}, {
        get: function get(_target, property) {
          return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _ref3;

            var module,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return script();

                  case 2:
                    module = _context.sent;
                    return _context.abrupt("return", (_ref3 = module)[property].apply(_ref3, _args));

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
        }
      });
    } // If we aren’t in an environment that supports Workers, just bail out
    // with a dummy worker that throws for every method call.


    if (typeof window === 'undefined') {
      return new Proxy({}, {
        get: function get(_target, _property) {
          return function () {
            throw new Error('You can’t call a method on a worker on the server.');
          };
        }
      });
    }

    throw new Error('Could not create a suitable fallback');
  }

  Reflect.defineProperty(createWorker, 'url', {
    value: scriptUrl
  });
  return createWorker;
}
function expose(caller, api) {
  var endpoint = getEndpoint(caller);
  endpoint === null || endpoint === void 0 ? void 0 : endpoint.expose(api);
  return endpoint != null;
}
function terminate(caller) {
  var endpoint = getEndpoint(caller);
  endpoint === null || endpoint === void 0 ? void 0 : endpoint.terminate();
  workerEndpointCache.delete(caller);
  return endpoint != null;
}
function getEndpoint(caller) {
  return workerEndpointCache.get(caller);
}

export { createWorkerFactory, expose, getEndpoint, terminate };
