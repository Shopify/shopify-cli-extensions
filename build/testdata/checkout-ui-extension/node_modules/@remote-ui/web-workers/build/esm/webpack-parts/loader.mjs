import { createForOfIteratorHelper as _createForOfIteratorHelper } from '../_virtual/_rollupPluginBabelHelpers.js';
import * as path from 'path';
import { getOptions } from 'loader-utils';
import SingleEntryPlugin from 'webpack/lib/SingleEntryPlugin';
import WebWorkerTemplatePlugin from 'webpack/lib/webworker/WebWorkerTemplatePlugin';
import FetchCompileWasmTemplatePlugin from 'webpack/lib/web/FetchCompileWasmTemplatePlugin';
import { WebWorkerPlugin } from './plugin.mjs';

var NAME = 'WebWorker';
var moduleWrapperCache = new Map();
function pitch(request) {
  var _plugin$options$filen;

  this.cacheable(false);
  var callback = this.async();
  var context = this.context,
      resourcePath = this.resourcePath,
      compiler = this._compiler,
      compilation = this._compilation;

  if (compiler.options.output.globalObject !== 'self') {
    return callback(new Error('webpackConfig.output.globalObject is not set to "self", which will cause chunk loading in the worker to fail. Please change the value to "self" for any builds targeting the browser, or set the {noop: true} option on the @remote-ui/web-workers babel plugin.'));
  }

  var plugin = (compiler.options.plugins || []).find(WebWorkerPlugin.isInstance);

  if (plugin == null) {
    throw new Error('You must also include the WebWorkerPlugin from `@remote-ui/web-workers` when using the Babel plugin.');
  }

  var options = getOptions(this) || {};
  var _options$name = options.name,
      name = _options$name === void 0 ? String(plugin.workerId++) : _options$name,
      wrapperModule = options.wrapperModule;
  var virtualModule = path.join(path.dirname(resourcePath), "".concat(path.basename(resourcePath, path.extname(resourcePath)), ".worker.js"));
  var wrapperContent;

  if (wrapperModule) {
    this.addDependency(wrapperModule);
    var cachedContent = moduleWrapperCache.get(wrapperModule);

    if (typeof cachedContent === 'string') {
      wrapperContent = cachedContent;
    } else if (cachedContent == null) {
      try {
        var _wrapperContent;

        wrapperContent = this.fs.readFileSync(wrapperModule).toString();
        moduleWrapperCache.set(wrapperModule, (_wrapperContent = wrapperContent) !== null && _wrapperContent !== void 0 ? _wrapperContent : false);
      } catch (error) {
        moduleWrapperCache.set(wrapperModule, false);
      }
    }
  }

  if (wrapperContent) {
    plugin.virtualModules.writeModule(virtualModule, wrapperContent.replace('{{WORKER_MODULE}}', JSON.stringify(request)));
  }

  var workerOptions = {
    filename: (_plugin$options$filen = plugin.options.filename) !== null && _plugin$options$filen !== void 0 ? _plugin$options$filen : addWorkerSubExtension(compiler.options.output.filename),
    chunkFilename: addWorkerSubExtension(compiler.options.output.chunkFilename),
    globalObject: plugin && plugin.options.globalObject || 'self'
  };
  var workerCompiler = compilation.createChildCompiler(NAME, workerOptions, []);
  workerCompiler.context = compiler.context;
  new WebWorkerTemplatePlugin({}).apply(workerCompiler);
  new FetchCompileWasmTemplatePlugin({
    mangleImports: compiler.options.optimization.mangleWasmImports
  }).apply(workerCompiler);
  new SingleEntryPlugin(context, wrapperContent == null ? request : virtualModule, name).apply(workerCompiler);

  var _iterator = _createForOfIteratorHelper(plugin.options.plugins || []),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var aPlugin = _step.value;
      aPlugin.apply(workerCompiler);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var subCache = "subcache ".concat(__dirname, " ").concat(request);
  workerCompiler.hooks.compilation.tap(NAME, function (compilation) {
    if (!compilation.cache) {
      return;
    }

    if (!compilation.cache[subCache]) {
      compilation.cache[subCache] = {};
    }

    compilation.cache = compilation.cache[subCache];
  });
  workerCompiler.runAsChild(function (error, entries, compilation) {
    var finalError;

    if (!error && compilation.errors && compilation.errors.length) {
      finalError = compilation.errors[0];
    }

    var entry = entries && entries[0] && entries[0].files[0];

    if (!finalError && !entry) {
      finalError = new Error("WorkerPlugin: no entry for ".concat(request));
    }

    if (finalError) {
      return callback(finalError);
    }

    return callback(null, "export default __webpack_public_path__ + ".concat(JSON.stringify(entry), ";"));
  });
}

function addWorkerSubExtension(file) {
  return file.includes('[name]') ? file.replace(/\.([a-z]+)$/i, '.worker.$1') : file.replace(/\.([a-z]+)$/i, '.[name].worker.$1');
}

var loader = {
  pitch: pitch
};

export default loader;
export { pitch };
