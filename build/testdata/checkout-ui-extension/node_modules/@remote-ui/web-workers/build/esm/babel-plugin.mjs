import { objectSpread2 as _objectSpread2, defineProperty as _defineProperty, createForOfIteratorHelper as _createForOfIteratorHelper, toConsumableArray as _toConsumableArray, typeof as _typeof } from './_virtual/_rollupPluginBabelHelpers.js';
import { resolve } from 'path';
import { runInNewContext } from 'vm';

var DEFAULT_PACKAGES_TO_PROCESS = {
  '@remote-ui/web-workers': [{
    name: 'createPlainWorkerFactory'
  }, {
    name: 'createWorkerFactory',
    wrapperModule: resolve(__dirname, 'wrappers/expose.js.raw')
  }]
};
var loader = resolve(__dirname, 'webpack-parts/loader');
function workerBabelPlugin(_ref) {
  var t = _ref.types,
      template = _ref.template;
  var noopBinding = template("() => (\n      new Proxy(\n        {},\n        {\n          get() {\n            return () => {\n              throw new Error('You can\u2019t call a method on a noop worker');\n            };\n          },\n        },\n      )\n    );", {
    sourceType: 'module'
  });
  return {
    visitor: {
      Program: function Program(program, state) {
        var _state$opts;

        state.program = program;
        var packages = (_state$opts = state.opts) !== null && _state$opts !== void 0 && _state$opts.packages ? normalize(state.opts.packages) : DEFAULT_PACKAGES_TO_PROCESS;
        state.process = new Map(Object.entries(packages));
      },
      ImportDeclaration: function ImportDeclaration(importDeclaration, state) {
        var processImports = state.process.get(importDeclaration.node.source.value);

        if (processImports == null) {
          return;
        }

        var _iterator = _createForOfIteratorHelper(importDeclaration.get('specifiers')),
            _step;

        try {
          var _loop = function _loop() {
            var specifier = _step.value;

            if (!specifier.isImportSpecifier() || specifier.node.imported.type !== 'Identifier') {
              return "continue";
            }

            var importedName = specifier.node.imported.name;
            var processableImport = processImports.find(function (_ref2) {
              var name = _ref2.name;
              return name === importedName;
            });

            if (processableImport == null) {
              return "continue";
            }

            var binding = specifier.scope.getBinding(specifier.node.imported.name);

            if (binding == null) {
              return "continue";
            }

            processBinding(binding, processableImport, state);
          };

          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  };

  function processBinding(binding, importOptions, state) {
    var program = state.program,
        _state$opts2 = state.opts,
        options = _state$opts2 === void 0 ? {} : _state$opts2;
    var _options$noop = options.noop,
        noop = _options$noop === void 0 ? false : _options$noop;
    var callingReferences = binding.referencePaths.filter(function (referencePath) {
      return referencePath.parentPath.isCallExpression();
    });

    var _iterator2 = _createForOfIteratorHelper(callingReferences),
        _step2;

    try {
      var _loop2 = function _loop2() {
        var referencePath = _step2.value;
        var callExpression = referencePath.parentPath;
        var dynamicImports = new Set();
        var firstArgument = callExpression.get('arguments')[0];
        firstArgument.traverse({
          Import: function Import(_ref3) {
            var parentPath = _ref3.parentPath;

            if (parentPath.isCallExpression()) {
              dynamicImports.add(parentPath);
            }
          }
        });

        if (dynamicImports.size === 0) {
          return {
            v: void 0
          };
        }

        if (dynamicImports.size > 1) {
          throw new Error('You made more than one dynamic import in the body of a web worker create function. Only one such import is allowed.');
        }

        var dynamicallyImported = _toConsumableArray(dynamicImports)[0].get('arguments')[0];

        var _dynamicallyImported$ = dynamicallyImported.evaluate(),
            imported = _dynamicallyImported$.value,
            confident = _dynamicallyImported$.confident;

        if (typeof imported !== 'string' || !confident) {
          throw new Error("Failed to evaluate a dynamic import to a string to create a web worker (".concat(dynamicallyImported.getSource(), ")"));
        }

        if (noop) {
          firstArgument.replaceWith(noopBinding());
          return {
            v: void 0
          };
        }

        var leadingComments = dynamicallyImported.node.leadingComments;

        var options = _objectSpread2(_objectSpread2({}, getLoaderOptions(leadingComments || [])), {}, {
          wrapperModule: importOptions.wrapperModule
        });

        var importId = callExpression.scope.generateUidIdentifier('worker');
        program.get('body')[0].insertBefore(t.importDeclaration([t.importDefaultSpecifier(importId)], t.stringLiteral("".concat(loader, "?").concat(JSON.stringify(options), "!").concat(imported))));
        firstArgument.replaceWith(importId);
      };

      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _ret2 = _loop2();

        if (_typeof(_ret2) === "object") return _ret2.v;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
}
// Reduced replication of webpackâ€™s logic for parsing import comments:
// https://github.com/webpack/webpack/blob/5147aed90ec8cd3633b0c45583f02afd16c7888d/lib/JavascriptParser.js#L2799-L2820
var webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);

function getLoaderOptions(comments) {
  return comments.reduce(function (options, comment) {
    var value = comment.value;

    if (!value || !webpackCommentRegExp.test(value)) {
      return options;
    }

    try {
      var _runInNewContext = runInNewContext("(function(){return {".concat(value, "};})()")),
          name = _runInNewContext.webpackChunkName;

      return name ? _objectSpread2(_objectSpread2({}, options), {}, {
        name: name
      }) : options;
    } catch (_unused) {
      return options;
    }
  }, {});
}

function normalize(packages) {
  return Object.keys(packages).reduce(function (all, pkg) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, pkg, packages[pkg].map(function (anImport) {
      return typeof anImport === 'string' ? {
        name: anImport
      } : anImport;
    })));
  }, {});
}

export default workerBabelPlugin;
export { DEFAULT_PACKAGES_TO_PROCESS };
