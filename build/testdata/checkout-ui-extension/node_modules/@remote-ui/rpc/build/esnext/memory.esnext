import { defineProperty as _defineProperty } from './_virtual/_rollupPluginBabelHelpers.js';
import { RETAINED_BY, RETAIN_METHOD, RELEASE_METHOD } from './types.esnext';
export { RELEASE_METHOD, RETAINED_BY, RETAIN_METHOD } from './types.esnext';

class StackFrame {
  constructor() {
    _defineProperty(this, "memoryManaged", new Set());
  }

  add(memoryManageable) {
    this.memoryManaged.add(memoryManageable);
    memoryManageable[RETAINED_BY].add(this);
    memoryManageable[RETAIN_METHOD]();
  }

  release() {
    for (const memoryManaged of this.memoryManaged) {
      memoryManaged[RETAINED_BY].delete(this);
      memoryManaged[RELEASE_METHOD]();
    }

    this.memoryManaged.clear();
  }

}
function isMemoryManageable(value) {
  return Boolean(value && value[RETAIN_METHOD] && value[RELEASE_METHOD]);
}
function retain(value, {
  deep = true
} = {}) {
  const canRetain = isMemoryManageable(value);

  if (canRetain) {
    value[RETAIN_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce((canRetain, item) => retain(item, {
        deep
      }) || canRetain, canRetain);
    } else if (typeof value === 'object' && value != null) {
      return Object.keys(value).reduce((canRetain, key) => retain(value[key], {
        deep
      }) || canRetain, canRetain);
    }
  }

  return canRetain;
}
function release(value, {
  deep = true
} = {}) {
  const canRelease = isMemoryManageable(value);

  if (canRelease) {
    value[RELEASE_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce((canRelease, item) => release(item, {
        deep
      }) || canRelease, canRelease);
    } else if (typeof value === 'object' && value != null) {
      return Object.keys(value).reduce((canRelease, key) => release(value[key], {
        deep
      }) || canRelease, canRelease);
    }
  }

  return canRelease;
}

export { StackFrame, isMemoryManageable, release, retain };
