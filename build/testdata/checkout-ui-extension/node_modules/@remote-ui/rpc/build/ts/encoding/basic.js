"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBasicEncoder = void 0;
const types_1 = require("../types");
const memory_1 = require("../memory");
const FUNCTION = '_@f';
function createBasicEncoder(api) {
    const functionsToId = new Map();
    const idsToFunction = new Map();
    const idsToProxy = new Map();
    return {
        encode,
        decode,
        async call(id, args) {
            const stackFrame = new memory_1.StackFrame();
            const func = idsToFunction.get(id);
            if (func == null) {
                throw new Error('You attempted to call a function that was already released.');
            }
            try {
                const retainedBy = memory_1.isMemoryManageable(func)
                    ? [stackFrame, ...func[types_1.RETAINED_BY]]
                    : [stackFrame];
                const result = await func(...decode(args, retainedBy));
                return result;
            }
            finally {
                stackFrame.release();
            }
        },
        release(id) {
            const func = idsToFunction.get(id);
            if (func) {
                idsToFunction.delete(id);
                functionsToId.delete(func);
            }
        },
        terminate() {
            functionsToId.clear();
            idsToFunction.clear();
            idsToProxy.clear();
        },
    };
    function encode(value) {
        if (typeof value === 'object') {
            if (value == null) {
                return [value];
            }
            const transferables = [];
            if (Array.isArray(value)) {
                const result = value.map((item) => {
                    const [result, nestedTransferables = []] = encode(item);
                    transferables.push(...nestedTransferables);
                    return result;
                });
                return [result, transferables];
            }
            const result = Object.keys(value).reduce((object, key) => {
                const [result, nestedTransferables = []] = encode(value[key]);
                transferables.push(...nestedTransferables);
                return Object.assign(Object.assign({}, object), { [key]: result });
            }, {});
            return [result, transferables];
        }
        if (typeof value === 'function') {
            if (functionsToId.has(value)) {
                const id = functionsToId.get(value);
                return [{ [FUNCTION]: id }];
            }
            const id = api.uuid();
            functionsToId.set(value, id);
            idsToFunction.set(id, value);
            return [{ [FUNCTION]: id }];
        }
        return [value];
    }
    function decode(value, retainedBy) {
        if (typeof value === 'object') {
            if (value == null) {
                return value;
            }
            if (Array.isArray(value)) {
                return value.map((value) => decode(value, retainedBy));
            }
            if (FUNCTION in value) {
                const id = value[FUNCTION];
                if (idsToProxy.has(id)) {
                    return idsToProxy.get(id);
                }
                let retainCount = 0;
                let released = false;
                const release = () => {
                    retainCount -= 1;
                    if (retainCount === 0) {
                        released = true;
                        idsToProxy.delete(id);
                        api.release(id);
                    }
                };
                const retain = () => {
                    retainCount += 1;
                };
                const retainers = new Set(retainedBy);
                const proxy = (...args) => {
                    if (released) {
                        throw new Error('You attempted to call a function that was already released.');
                    }
                    if (!idsToProxy.has(id)) {
                        throw new Error('You attempted to call a function that was already revoked.');
                    }
                    return api.call(id, args);
                };
                Object.defineProperties(proxy, {
                    [types_1.RELEASE_METHOD]: { value: release, writable: false },
                    [types_1.RETAIN_METHOD]: { value: retain, writable: false },
                    [types_1.RETAINED_BY]: { value: retainers, writable: false },
                });
                for (const retainer of retainers) {
                    retainer.add(proxy);
                }
                idsToProxy.set(id, proxy);
                return proxy;
            }
            return Object.keys(value).reduce((object, key) => (Object.assign(Object.assign({}, object), { [key]: decode(value[key], retainedBy) })), {});
        }
        return value;
    }
}
exports.createBasicEncoder = createBasicEncoder;
