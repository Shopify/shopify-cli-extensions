"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = exports.retain = exports.isMemoryManageable = exports.StackFrame = exports.RELEASE_METHOD = exports.RETAIN_METHOD = exports.RETAINED_BY = void 0;
const types_1 = require("./types");
Object.defineProperty(exports, "RETAINED_BY", { enumerable: true, get: function () { return types_1.RETAINED_BY; } });
Object.defineProperty(exports, "RETAIN_METHOD", { enumerable: true, get: function () { return types_1.RETAIN_METHOD; } });
Object.defineProperty(exports, "RELEASE_METHOD", { enumerable: true, get: function () { return types_1.RELEASE_METHOD; } });
class StackFrame {
    constructor() {
        this.memoryManaged = new Set();
    }
    add(memoryManageable) {
        this.memoryManaged.add(memoryManageable);
        memoryManageable[types_1.RETAINED_BY].add(this);
        memoryManageable[types_1.RETAIN_METHOD]();
    }
    release() {
        for (const memoryManaged of this.memoryManaged) {
            memoryManaged[types_1.RETAINED_BY].delete(this);
            memoryManaged[types_1.RELEASE_METHOD]();
        }
        this.memoryManaged.clear();
    }
}
exports.StackFrame = StackFrame;
function isMemoryManageable(value) {
    return Boolean(value && value[types_1.RETAIN_METHOD] && value[types_1.RELEASE_METHOD]);
}
exports.isMemoryManageable = isMemoryManageable;
function retain(value, { deep = true } = {}) {
    const canRetain = isMemoryManageable(value);
    if (canRetain) {
        value[types_1.RETAIN_METHOD]();
    }
    if (deep) {
        if (Array.isArray(value)) {
            return value.reduce((canRetain, item) => retain(item, { deep }) || canRetain, canRetain);
        }
        else if (typeof value === 'object' && value != null) {
            return Object.keys(value).reduce((canRetain, key) => retain(value[key], { deep }) || canRetain, canRetain);
        }
    }
    return canRetain;
}
exports.retain = retain;
function release(value, { deep = true } = {}) {
    const canRelease = isMemoryManageable(value);
    if (canRelease) {
        value[types_1.RELEASE_METHOD]();
    }
    if (deep) {
        if (Array.isArray(value)) {
            return value.reduce((canRelease, item) => release(item, { deep }) || canRelease, canRelease);
        }
        else if (typeof value === 'object' && value != null) {
            return Object.keys(value).reduce((canRelease, key) => release(value[key], { deep }) || canRelease, canRelease);
        }
    }
    return canRelease;
}
exports.release = release;
