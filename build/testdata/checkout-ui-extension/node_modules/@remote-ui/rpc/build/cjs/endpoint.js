'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var memory = require('./memory.js');
var basic = require('./encoding/basic.js');

var CALL = 0;
var RESULT = 1;
var TERMINATE = 2;
var RELEASE = 3;
var FUNCTION_APPLY = 5;
var FUNCTION_RESULT = 6;

/**
 * An endpoint wraps around a messenger, acting as the intermediary for all
 * messages both send from, and received by, that messenger. The endpoint sends
 * all messages as arrays, where the first element is the message type, and the
 * second is the arguments for that message (as an array). For messages that send
 * meaningful content across the wire (e.g., arguments to function calls, return
 * results), the endpoint first encodes these values.
 *
 * Encoding is done using a CBOR-like encoding scheme. The value is encoded into
 * an array buffer, and is paired with an additional array buffer that contains all
 * the strings used in that message (in the encoded value, strings are encoded as
 * their index in the "strings" encoding to reduce the cost of heavily-duplicated
 * strings, which is more likely in payloads containing UI). This encoding also takes
 * care of encoding functions: it uses a "tagged" item in CBOR to represent a
 * function as a string ID, which the opposite endpoint will be capable of turning
 * into a consistent, memory-manageable function proxy.
 *
 * The main CBOR encoding is entirely take from the [cbor.js package](https://github.com/paroga/cbor-js).
 * The special behavior for encoding strings and functions was then added in to the
 * encoder and decoder. For additional details on CBOR:
 *
 * @see https://tools.ietf.org/html/rfc7049
 */
function createEndpoint(initialMessenger) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$uuid = _ref.uuid,
      uuid = _ref$uuid === void 0 ? defaultUuid : _ref$uuid,
      _ref$createEncoder = _ref.createEncoder,
      createEncoder = _ref$createEncoder === void 0 ? basic.createBasicEncoder : _ref$createEncoder,
      callable = _ref.callable;

  var terminated = false;
  var messenger = initialMessenger;
  var activeApi = new Map();
  var callIdsToResolver = new Map();
  var call = createCallable(handlerForCall, callable);
  var encoder = createEncoder({
    uuid: uuid,
    release: function release(id) {
      send(RELEASE, [id]);
    },
    call: function call(id, args, retainedBy) {
      var callId = uuid();
      var done = waitForResult(callId, retainedBy);

      var _encoder$encode = encoder.encode(args),
          _encoder$encode2 = _rollupPluginBabelHelpers.slicedToArray(_encoder$encode, 2),
          encoded = _encoder$encode2[0],
          transferables = _encoder$encode2[1];

      send(FUNCTION_APPLY, [callId, id, encoded], transferables);
      return done;
    }
  });
  messenger.addEventListener('message', listener);
  return {
    call: call,
    replace: function replace(newMessenger) {
      var oldMessenger = messenger;
      messenger = newMessenger;
      oldMessenger.removeEventListener('message', listener);
      newMessenger.addEventListener('message', listener);
    },
    expose: function expose(api) {
      for (var _i = 0, _Object$keys = Object.keys(api); _i < _Object$keys.length; _i++) {
        var _key = _Object$keys[_i];
        var value = api[_key];

        if (typeof value === 'function') {
          activeApi.set(_key, value);
        } else {
          activeApi.delete(_key);
        }
      }
    },
    callable: function (_callable) {
      function callable() {
        return _callable.apply(this, arguments);
      }

      callable.toString = function () {
        return _callable.toString();
      };

      return callable;
    }(function () {
      // If no callable methods are supplied initially, we use a Proxy instead,
      // so all methods end up being treated as callable by default.
      if (callable == null) return;

      for (var _len = arguments.length, newCallable = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        newCallable[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _newCallable = newCallable; _i2 < _newCallable.length; _i2++) {
        var method = _newCallable[_i2];
        Object.defineProperty(call, method, {
          value: handlerForCall(method),
          writable: false,
          configurable: true,
          enumerable: true
        });
      }
    }),
    terminate: function (_terminate) {
      function terminate() {
        return _terminate.apply(this, arguments);
      }

      terminate.toString = function () {
        return _terminate.toString();
      };

      return terminate;
    }(function () {
      terminate();

      if (messenger.terminate) {
        messenger.terminate();
      } else {
        send(TERMINATE, []);
      }
    })
  };

  function send(type, args, transferables) {
    messenger.postMessage([type, args], transferables);
  }

  function listener(_x) {
    return _listener.apply(this, arguments);
  }

  function _listener() {
    _listener = _rollupPluginBabelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {
      var data, stackFrame, _ref2, _ref3, id, _property, args, func, _encoder$encode5, _encoder$encode6, encoded, transferables, name, message, stack, _ref4, _ref5, callId, _ref6, _ref7, _id, _ref8, _ref9, _callId, _ref10, _ref11, _callId2, funcId, _args, result, _encoder$encode7, _encoder$encode8, _encoded, _transferables, _name, _message, _stack;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              data = event.data;

              if (!(data == null || !Array.isArray(data))) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              _context.t0 = data[0];
              _context.next = _context.t0 === TERMINATE ? 6 : _context.t0 === CALL ? 8 : _context.t0 === RESULT ? 34 : _context.t0 === RELEASE ? 38 : _context.t0 === FUNCTION_RESULT ? 41 : _context.t0 === FUNCTION_APPLY ? 45 : 60;
              break;

            case 6:
              terminate();
              return _context.abrupt("break", 60);

            case 8:
              stackFrame = new memory.StackFrame();
              _ref2 = data[1], _ref3 = _rollupPluginBabelHelpers.slicedToArray(_ref2, 3), id = _ref3[0], _property = _ref3[1], args = _ref3[2];
              func = activeApi.get(_property);
              _context.prev = 11;

              if (!(func == null)) {
                _context.next = 14;
                break;
              }

              throw new Error("No '".concat(_property, "' method is exposed on this endpoint"));

            case 14:
              _context.t1 = encoder;
              _context.next = 17;
              return func.apply(void 0, _rollupPluginBabelHelpers.toConsumableArray(encoder.decode(args, [stackFrame])));

            case 17:
              _context.t2 = _context.sent;
              _encoder$encode5 = _context.t1.encode.call(_context.t1, _context.t2);
              _encoder$encode6 = _rollupPluginBabelHelpers.slicedToArray(_encoder$encode5, 2);
              encoded = _encoder$encode6[0];
              transferables = _encoder$encode6[1];
              send(RESULT, [id, undefined, encoded], transferables);
              _context.next = 30;
              break;

            case 25:
              _context.prev = 25;
              _context.t3 = _context["catch"](11);
              name = _context.t3.name, message = _context.t3.message, stack = _context.t3.stack;
              send(RESULT, [id, {
                name: name,
                message: message,
                stack: stack
              }]);
              throw _context.t3;

            case 30:
              _context.prev = 30;
              stackFrame.release();
              return _context.finish(30);

            case 33:
              return _context.abrupt("break", 60);

            case 34:
              _ref4 = data[1], _ref5 = _rollupPluginBabelHelpers.slicedToArray(_ref4, 1), callId = _ref5[0];
              callIdsToResolver.get(callId).apply(void 0, _rollupPluginBabelHelpers.toConsumableArray(data[1]));
              callIdsToResolver.delete(callId);
              return _context.abrupt("break", 60);

            case 38:
              _ref6 = data[1], _ref7 = _rollupPluginBabelHelpers.slicedToArray(_ref6, 1), _id = _ref7[0];
              encoder.release(_id);
              return _context.abrupt("break", 60);

            case 41:
              _ref8 = data[1], _ref9 = _rollupPluginBabelHelpers.slicedToArray(_ref8, 1), _callId = _ref9[0];
              callIdsToResolver.get(_callId).apply(void 0, _rollupPluginBabelHelpers.toConsumableArray(data[1]));
              callIdsToResolver.delete(_callId);
              return _context.abrupt("break", 60);

            case 45:
              _ref10 = data[1], _ref11 = _rollupPluginBabelHelpers.slicedToArray(_ref10, 3), _callId2 = _ref11[0], funcId = _ref11[1], _args = _ref11[2];
              _context.prev = 46;
              _context.next = 49;
              return encoder.call(funcId, _args);

            case 49:
              result = _context.sent;
              _encoder$encode7 = encoder.encode(result), _encoder$encode8 = _rollupPluginBabelHelpers.slicedToArray(_encoder$encode7, 2), _encoded = _encoder$encode8[0], _transferables = _encoder$encode8[1];
              send(FUNCTION_RESULT, [_callId2, undefined, _encoded], _transferables);
              _context.next = 59;
              break;

            case 54:
              _context.prev = 54;
              _context.t4 = _context["catch"](46);
              _name = _context.t4.name, _message = _context.t4.message, _stack = _context.t4.stack;
              send(FUNCTION_RESULT, [_callId2, {
                name: _name,
                message: _message,
                stack: _stack
              }]);
              throw _context.t4;

            case 59:
              return _context.abrupt("break", 60);

            case 60:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[11, 25, 30, 33], [46, 54]]);
    }));
    return _listener.apply(this, arguments);
  }

  function handlerForCall(property) {
    return function () {
      if (terminated) {
        throw new Error('You attempted to call a function on a terminated web worker.');
      }

      if (typeof property !== 'string' && typeof property !== 'number') {
        throw new Error("Can\u2019t call a symbol method on a remote endpoint: ".concat(property.toString()));
      }

      var id = uuid();
      var done = waitForResult(id);

      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var _encoder$encode3 = encoder.encode(args),
          _encoder$encode4 = _rollupPluginBabelHelpers.slicedToArray(_encoder$encode3, 2),
          encoded = _encoder$encode4[0],
          transferables = _encoder$encode4[1];

      send(CALL, [id, property, encoded], transferables);
      return done;
    };
  }

  function waitForResult(id, retainedBy) {
    return new Promise(function (resolve, reject) {
      callIdsToResolver.set(id, function (_, errorResult, value) {
        if (errorResult == null) {
          resolve(value && encoder.decode(value, retainedBy));
        } else {
          var error = new Error();
          Object.assign(error, errorResult);
          reject(error);
        }
      });
    });
  }

  function terminate() {
    var _encoder$terminate;

    terminated = true;
    activeApi.clear();
    callIdsToResolver.clear();
    (_encoder$terminate = encoder.terminate) === null || _encoder$terminate === void 0 ? void 0 : _encoder$terminate.call(encoder);
    messenger.removeEventListener('message', listener);
  }
}

function defaultUuid() {
  return "".concat(uuidSegment(), "-").concat(uuidSegment(), "-").concat(uuidSegment(), "-").concat(uuidSegment());
}

function uuidSegment() {
  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);
}

function createCallable(handlerForCall, callable) {
  var call;

  if (callable == null) {
    if (typeof Proxy !== 'function') {
      throw new Error("You must pass an array of callable methods in environments without Proxies.");
    }

    var cache = new Map();
    call = new Proxy({}, {
      get: function get(_target, property) {
        if (cache.has(property)) {
          return cache.get(property);
        }

        var handler = handlerForCall(property);
        cache.set(property, handler);
        return handler;
      }
    });
  } else {
    call = {};

    var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(callable),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var method = _step.value;
        Object.defineProperty(call, method, {
          value: handlerForCall(method),
          writable: false,
          configurable: true,
          enumerable: true
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return call;
}

exports.createEndpoint = createEndpoint;
