'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var types = require('./types.js');

var StackFrame = /*#__PURE__*/function () {
  function StackFrame() {
    _rollupPluginBabelHelpers.classCallCheck(this, StackFrame);

    _rollupPluginBabelHelpers.defineProperty(this, "memoryManaged", new Set());
  }

  _rollupPluginBabelHelpers.createClass(StackFrame, [{
    key: "add",
    value: function add(memoryManageable) {
      this.memoryManaged.add(memoryManageable);
      memoryManageable[types.RETAINED_BY].add(this);
      memoryManageable[types.RETAIN_METHOD]();
    }
  }, {
    key: "release",
    value: function release() {
      var _iterator = _rollupPluginBabelHelpers.createForOfIteratorHelper(this.memoryManaged),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var memoryManaged = _step.value;
          memoryManaged[types.RETAINED_BY].delete(this);
          memoryManaged[types.RELEASE_METHOD]();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.memoryManaged.clear();
    }
  }]);

  return StackFrame;
}();
function isMemoryManageable(value) {
  return Boolean(value && value[types.RETAIN_METHOD] && value[types.RELEASE_METHOD]);
}
function retain(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$deep = _ref.deep,
      deep = _ref$deep === void 0 ? true : _ref$deep;

  var canRetain = isMemoryManageable(value);

  if (canRetain) {
    value[types.RETAIN_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce(function (canRetain, item) {
        return retain(item, {
          deep: deep
        }) || canRetain;
      }, canRetain);
    } else if (_rollupPluginBabelHelpers['typeof'](value) === 'object' && value != null) {
      return Object.keys(value).reduce(function (canRetain, key) {
        return retain(value[key], {
          deep: deep
        }) || canRetain;
      }, canRetain);
    }
  }

  return canRetain;
}
function release(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$deep = _ref2.deep,
      deep = _ref2$deep === void 0 ? true : _ref2$deep;

  var canRelease = isMemoryManageable(value);

  if (canRelease) {
    value[types.RELEASE_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce(function (canRelease, item) {
        return release(item, {
          deep: deep
        }) || canRelease;
      }, canRelease);
    } else if (_rollupPluginBabelHelpers['typeof'](value) === 'object' && value != null) {
      return Object.keys(value).reduce(function (canRelease, key) {
        return release(value[key], {
          deep: deep
        }) || canRelease;
      }, canRelease);
    }
  }

  return canRelease;
}

exports.RELEASE_METHOD = types.RELEASE_METHOD;
exports.RETAINED_BY = types.RETAINED_BY;
exports.RETAIN_METHOD = types.RETAIN_METHOD;
exports.StackFrame = StackFrame;
exports.isMemoryManageable = isMemoryManageable;
exports.release = release;
exports.retain = retain;
