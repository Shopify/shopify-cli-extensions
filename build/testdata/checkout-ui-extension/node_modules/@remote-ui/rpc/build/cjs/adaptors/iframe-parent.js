'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.js');

function fromIframe(target) {
  var _target$contentDocume;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$terminate = _ref.terminate,
      shouldTerminate = _ref$terminate === void 0 ? true : _ref$terminate,
      _ref$targetOrigin = _ref.targetOrigin,
      targetOrigin = _ref$targetOrigin === void 0 ? '*' : _ref$targetOrigin;

  if (typeof window === 'undefined') {
    throw new Error("You can only run fromIframe() in a browser context, but no window was found.");
  } // We need to store the listener, because we wrap it to do some origin checking. Ideally,
  // we’d instead store an `AbortController`, and use its signal to cancel the listeners,
  // but that isn’t widely supported.


  var listenerMap = new WeakMap();
  var iframeLoadPromise = ((_target$contentDocume = target.contentDocument) === null || _target$contentDocume === void 0 ? void 0 : _target$contentDocume.readyState) === 'complete' ? Promise.resolve() : new Promise(function (resolve) {
    target.addEventListener('load', function () {
      return resolve();
    }, {
      once: true
    });
  });
  return {
    postMessage: function postMessage(message, transfer) {
      return _rollupPluginBabelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _target$contentDocume2;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(((_target$contentDocume2 = target.contentDocument) === null || _target$contentDocume2 === void 0 ? void 0 : _target$contentDocume2.readyState) !== 'complete')) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return iframeLoadPromise;

              case 3:
                target.contentWindow.postMessage(message, targetOrigin, transfer);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    addEventListener: function addEventListener(event, listener) {
      var wrappedListener = function wrappedListener(event) {
        if (event.source !== target.contentWindow) return;
        listener(event);
      };

      listenerMap.set(listener, wrappedListener);
      self.addEventListener(event, wrappedListener);
    },
    removeEventListener: function removeEventListener(event, listener) {
      var wrappedListener = listenerMap.get(listener);
      if (wrappedListener == null) return;
      listenerMap.delete(listener);
      self.removeEventListener(event, wrappedListener);
    },
    terminate: function terminate() {
      if (shouldTerminate) target.remove();
    }
  };
}

exports.fromIframe = fromIframe;
