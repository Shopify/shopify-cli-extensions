import { asyncToGenerator as _asyncToGenerator, typeof as _typeof, slicedToArray as _slicedToArray, toConsumableArray as _toConsumableArray, objectSpread2 as _objectSpread2, defineProperty as _defineProperty, createForOfIteratorHelper as _createForOfIteratorHelper } from '../_virtual/_rollupPluginBabelHelpers.js';
import { RETAINED_BY, RELEASE_METHOD, RETAIN_METHOD } from '../types.mjs';
import { isMemoryManageable, StackFrame } from '../memory.mjs';

var FUNCTION = '_@f';
function createBasicEncoder(api) {
  var functionsToId = new Map();
  var idsToFunction = new Map();
  var idsToProxy = new Map();
  return {
    encode: encode,
    decode: decode,
    call: function call(id, args) {
      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var stackFrame, func, retainedBy, result;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                stackFrame = new StackFrame();
                func = idsToFunction.get(id);

                if (!(func == null)) {
                  _context.next = 4;
                  break;
                }

                throw new Error('You attempted to call a function that was already released.');

              case 4:
                _context.prev = 4;
                retainedBy = isMemoryManageable(func) ? [stackFrame].concat(_toConsumableArray(func[RETAINED_BY])) : [stackFrame];
                _context.next = 8;
                return func.apply(void 0, _toConsumableArray(decode(args, retainedBy)));

              case 8:
                result = _context.sent;
                return _context.abrupt("return", result);

              case 10:
                _context.prev = 10;
                stackFrame.release();
                return _context.finish(10);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[4,, 10, 13]]);
      }))();
    },
    release: function release(id) {
      var func = idsToFunction.get(id);

      if (func) {
        idsToFunction.delete(id);
        functionsToId.delete(func);
      }
    },
    terminate: function terminate() {
      functionsToId.clear();
      idsToFunction.clear();
      idsToProxy.clear();
    }
  };

  function encode(value) {
    if (_typeof(value) === 'object') {
      if (value == null) {
        return [value];
      }

      var transferables = [];

      if (Array.isArray(value)) {
        var _result = value.map(function (item) {
          var _encode = encode(item),
              _encode2 = _slicedToArray(_encode, 2),
              result = _encode2[0],
              _encode2$ = _encode2[1],
              nestedTransferables = _encode2$ === void 0 ? [] : _encode2$;

          transferables.push.apply(transferables, _toConsumableArray(nestedTransferables));
          return result;
        });

        return [_result, transferables];
      }

      var result = Object.keys(value).reduce(function (object, key) {
        var _encode3 = encode(value[key]),
            _encode4 = _slicedToArray(_encode3, 2),
            result = _encode4[0],
            _encode4$ = _encode4[1],
            nestedTransferables = _encode4$ === void 0 ? [] : _encode4$;

        transferables.push.apply(transferables, _toConsumableArray(nestedTransferables));
        return _objectSpread2(_objectSpread2({}, object), {}, _defineProperty({}, key, result));
      }, {});
      return [result, transferables];
    }

    if (typeof value === 'function') {
      if (functionsToId.has(value)) {
        var _id = functionsToId.get(value);

        return [_defineProperty({}, FUNCTION, _id)];
      }

      var id = api.uuid();
      functionsToId.set(value, id);
      idsToFunction.set(id, value);
      return [_defineProperty({}, FUNCTION, id)];
    }

    return [value];
  }

  function decode(value, retainedBy) {
    if (_typeof(value) === 'object') {
      if (value == null) {
        return value;
      }

      if (Array.isArray(value)) {
        return value.map(function (value) {
          return decode(value, retainedBy);
        });
      }

      if (FUNCTION in value) {
        var _Object$definePropert;

        var id = value[FUNCTION];

        if (idsToProxy.has(id)) {
          return idsToProxy.get(id);
        }

        var retainCount = 0;
        var released = false;

        var release = function release() {
          retainCount -= 1;

          if (retainCount === 0) {
            released = true;
            idsToProxy.delete(id);
            api.release(id);
          }
        };

        var retain = function retain() {
          retainCount += 1;
        };

        var retainers = new Set(retainedBy);

        var proxy = function proxy() {
          if (released) {
            throw new Error('You attempted to call a function that was already released.');
          }

          if (!idsToProxy.has(id)) {
            throw new Error('You attempted to call a function that was already revoked.');
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return api.call(id, args);
        };

        Object.defineProperties(proxy, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, RELEASE_METHOD, {
          value: release,
          writable: false
        }), _defineProperty(_Object$definePropert, RETAIN_METHOD, {
          value: retain,
          writable: false
        }), _defineProperty(_Object$definePropert, RETAINED_BY, {
          value: retainers,
          writable: false
        }), _Object$definePropert));

        var _iterator = _createForOfIteratorHelper(retainers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var retainer = _step.value;
            retainer.add(proxy);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        idsToProxy.set(id, proxy);
        return proxy;
      }

      return Object.keys(value).reduce(function (object, key) {
        return _objectSpread2(_objectSpread2({}, object), {}, _defineProperty({}, key, decode(value[key], retainedBy)));
      }, {});
    }

    return value;
  }
}

export { createBasicEncoder };
