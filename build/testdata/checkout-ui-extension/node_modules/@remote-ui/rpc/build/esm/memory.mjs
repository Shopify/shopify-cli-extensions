import { createClass as _createClass, typeof as _typeof, classCallCheck as _classCallCheck, defineProperty as _defineProperty, createForOfIteratorHelper as _createForOfIteratorHelper } from './_virtual/_rollupPluginBabelHelpers.js';
import { RETAIN_METHOD, RELEASE_METHOD, RETAINED_BY } from './types.mjs';
export { RELEASE_METHOD, RETAINED_BY, RETAIN_METHOD } from './types.mjs';

var StackFrame = /*#__PURE__*/function () {
  function StackFrame() {
    _classCallCheck(this, StackFrame);

    _defineProperty(this, "memoryManaged", new Set());
  }

  _createClass(StackFrame, [{
    key: "add",
    value: function add(memoryManageable) {
      this.memoryManaged.add(memoryManageable);
      memoryManageable[RETAINED_BY].add(this);
      memoryManageable[RETAIN_METHOD]();
    }
  }, {
    key: "release",
    value: function release() {
      var _iterator = _createForOfIteratorHelper(this.memoryManaged),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var memoryManaged = _step.value;
          memoryManaged[RETAINED_BY].delete(this);
          memoryManaged[RELEASE_METHOD]();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.memoryManaged.clear();
    }
  }]);

  return StackFrame;
}();
function isMemoryManageable(value) {
  return Boolean(value && value[RETAIN_METHOD] && value[RELEASE_METHOD]);
}
function retain(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$deep = _ref.deep,
      deep = _ref$deep === void 0 ? true : _ref$deep;

  var canRetain = isMemoryManageable(value);

  if (canRetain) {
    value[RETAIN_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce(function (canRetain, item) {
        return retain(item, {
          deep: deep
        }) || canRetain;
      }, canRetain);
    } else if (_typeof(value) === 'object' && value != null) {
      return Object.keys(value).reduce(function (canRetain, key) {
        return retain(value[key], {
          deep: deep
        }) || canRetain;
      }, canRetain);
    }
  }

  return canRetain;
}
function release(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$deep = _ref2.deep,
      deep = _ref2$deep === void 0 ? true : _ref2$deep;

  var canRelease = isMemoryManageable(value);

  if (canRelease) {
    value[RELEASE_METHOD]();
  }

  if (deep) {
    if (Array.isArray(value)) {
      return value.reduce(function (canRelease, item) {
        return release(item, {
          deep: deep
        }) || canRelease;
      }, canRelease);
    } else if (_typeof(value) === 'object' && value != null) {
      return Object.keys(value).reduce(function (canRelease, key) {
        return release(value[key], {
          deep: deep
        }) || canRelease;
      }, canRelease);
    }
  }

  return canRelease;
}

export { StackFrame, isMemoryManageable, release, retain };
